'.source.sql-bigquery':
  '#standardSQL':
    'prefix': 'standard'
    'body': '#standardSQL'
  '#legacySQL':
    'prefix': 'legacy'
    'body': '#legacySQL'

  '`TABLE-NAME`':
    'prefix': 'table'
    'body': '`${1:project}.${2:dataset}.${3:table}`'
  '[TABLE-NAME]':
    'prefix': 'table legacy'
    'body': '[${1:project}:${2:dataset}.${3:table}]'

  'SELECT ... FROM':
    'prefix': 'select'
    'body': """
      select
      \t${1:column}
      from `${2:project}.${3:dataset}.${4:table}`
      where ${5:condition}
    """

  'INNER JOIN':
    'prefix': 'inner join'
    'body': 'inner join `${1:project}.${2:dataset}.${3:table}`'
  'LEFT JOIN':
    'prefix': 'left join'
    'body': 'left join `${1:project}.${2:dataset}.${3:table}`'
  'RIGHT JOIN':
    'prefix': 'right join'
    'body': 'right join `${1:project}.${2:dataset}.${3:table}`'
  'FULL OUTER JOIN':
    'prefix': 'full join'
    'body': 'full outer join `${1:project}.${2:dataset}.${3:table}`'
  'BETWEEN ... AND':
    'prefix': 'between'
    'body': '${1} between ${2} and ${3}'
  'IN (value, ...)':
    'prefix': 'in'
    'body': 'in (${1:value, ...})'
  'GROUP BY':
    'prefix': 'groupby'
    'body': 'group by ${1}'
  'ORDER BY':
    'prefix': 'orderby'
    'body': 'order by ${1}'
  'PARTITION BY':
    'prefix': 'partitionby'
    'body': 'partition by ${1:date(_PARTITIONTIME)|date(<timestamp_column>)|<date_column>}'
  'CLUSTER BY':
    'prefix': 'clusterby'
    'body': 'cluster by ${1:clustering_column_list}'
  'WITH ... AS':
    'prefix': 'with'
    'body': """
      with ${1:with_query_name} as (
        select
          ${2}
        from
          `${3:project}.${4:dataset}.${5:table}`
      )

    """

  '_TABLE_SUFFIX BETWEEN ...':
    'prefix': '_tablesuffix'
    'body': '_TABLE_SUFFIX between "${1:from}" and "${2:to}"'
  '_TABLE_SUFFIX BETWEEN ..':
    'prefix': 'tablesuffix'
    'body': '_TABLE_SUFFIX between "${1:from}" and "${2:to}"'

  '_PARTITIONTIME BETWEEN ...':
    'prefix': '_partitiontime'
    'body': '_PARTITIONTIME between "${1:yyyy-mm-dd}" and "${2:yyyy-mm-dd}"'
  '_PARTITIONTIME BETWEEN ..':
    'prefix': 'partitiontime'
    'body': '_PARTITIONTIME between "${1:yyyy-mm-dd}" and "${2:yyyy-mm-dd}"'

  'INSERT INTO':
    'prefix': 'insert'
    'body': """
      insert into `${1:project}.${2:dataset}.${3:table}`
      \t(${4:column, ...})
      values
      \t(${6:expr, ...})
    """
  'INSERT INTO SELECT':
    'prefix': 'insert select'
    'body': """
      insert into `${1:project}.${2:dataset}.${3:table}`
      \t(${4:column, ...})
      select
      \t${5:column}
      from `${6:project}.${7:dataset}.${8:table}`
      where ${9:condition}
    """

  'DELETE FROM ...':
    'prefix': 'delete'
    'body': """
      delete from `${1:project}.${2:dataset}.${3:table}`
      where ${4:condition}
    """

  'UPDATE ... SET':
    'prefix': 'update'
    'body': """
      update `${1:project}.${2:dataset}.${3:table}`
      set ${4:column} = ${5:value}
      where ${6:condition}
    """
  'UPDATE ... SET FROM':
    'prefix': 'update from'
    'body': """
      update `${1:project}.${2:dataset}.${3:table}` a
      set ${4:column} = ${5:value}
      from `${6:project}.${7:dataset}.${8:table}` b
      where a.${9:column} = b.${9:column}
    """

  'MERGE':
    'prefix': 'merge'
    'body': """
      merge into `${1:project}.${2:dataset}.${3:target_table}` t
      using `${4:project}.${5:dataset}.${6:source_table}` s
      on ${7:merge_condition}
      when matched then
      \tupdate set ${8:target_column} = ${9:value}
      when not matched then
      \tinsert (${10:target_column, ...}) values(${11:source_column, ...})
      when matched and ${12:other_condition} then
      \tdelete
    """

  'CREATE TABLE':
    'prefix': 'create table'
    'body': """
      create table `${1:project}.${2:dataset}.${3:table}`
      (
      \t${4:column} ${5:type}${6: options (description = "comment")}
      )
    """
  'CREATE TABLE IF NOT EXISTS':
    'prefix': 'create table if not exists'
    'body': """
      create table if not exsists `${1:project}.${2:dataset}.${3:table}`
      (
      \t${4:column} ${5:type}${6: options (description = "comment")}
      )
    """
  'CREATE OR REPLACE TABLE':
    'prefix': 'create or replace table'
    'body': """
      create or replace table `${1:project}.${2:dataset}.${3:table}`
      (
      \t${4:column} ${5:type}${6: options (description = "comment")}
      )
    """
  'CREATE TABLE ... PARTITION BY':
    'prefix': 'create table partition'
    'body': """
      create table `${1:project}.${2:dataset}.${3:table}`
      (
      \t${4:column} ${5:type}${6: options (description = "comment")}
      )
      partition by ${7:date(_PARTITIONTIME)|date(<timestamp_column>)|<date_column>}
      ${8:[cluster by clustering_column_list]}
    """
  'CREATE TABLE AS SELECT':
    'prefix': 'create table as select'
    'body': """
      create table `${1:project}.${2:dataset}.${3:table}`
      (
      \t${4:column} ${5:type}${6: options (description = "comment")}
      ) as
      select
      \t${7:column}
      from `${8:project}.${9:dataset}.${10:table}`
      where ${11:condition}
    """
  'CREATE TABLE OPTIONS':
    'prefix': 'create table options'
    'body': """
      options (
      \tdescription = "description",
      \texpiration_timestamp = timestamp "YYYY-MM-DD HH:MI:SS UTC",
      \tpartition_expiration_days = 1,
      \trequire_partition_filter = false,
      \tkms_key_name = "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]",
      \tfriendly_name = "friendly_name",
      \tlabels = [("key", "value")]
      )
    """
  'OPTIONS':
    'prefix': 'options'
    'body': """
      options (
      \tdescription = "description",
      \texpiration_timestamp = timestamp "YYYY-MM-DD HH:MI:SS UTC",
      \tpartition_expiration_days = 1,
      \trequire_partition_filter = false,
      \tkms_key_name = "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]",
      \tfriendly_name = "friendly_name",
      \tlabels = [("key", "value")]
      )
    """

  'CREATE VIEW':
    'prefix': 'create view'
    'body': """
      create view `${1:project}.${2:dataset}.${3:view}`
      as
      select
      from `${5:project}.${5:dataset}.${6:table}`
    """
  'CREATE VIEW IF NOT EXISTS':
    'prefix': 'create view if not exists'
    'body': """
      create view if not exists `${1:project}.${2:dataset}.${3:view}`
      as
      select
      from `${5:project}.${5:dataset}.${6:table}`
    """
  'CREATE OR REPLACE VIEW':
    'prefix': 'create or replace view'
    'body': """
      create or replace view `${1:project}.${2:dataset}.${3:view}`
      as
      select
      from `${5:project}.${5:dataset}.${6:table}`
    """

  'CREATE JavaScript FUNCTION':
    'prefix': 'create function javascript'
    'body': """
      create temporary function ${1:functionName}(${2:param_name param_type[, ...]})
      returns ${3:data_type}
      language js as \"\"\"
      \t${4:return \"expression\";}
      \"\"\";
    """
  'CREATE SQL FUNCTION':
    'prefix': 'create function sql'
    'body': """
      create temporary function ${1:functionName}(${2:param_name param_type[, ...]})
      ${3:[returns data_type]}
      as (
      \t${4:sql_expression}
      );
    """

  'CREATE MODEL':
    'prefix': 'create model'
    'body': """
      ${1:create model | create model if not exists | create or replace model} `${2:project}.${3:dataset}.${4:model}`
      ${5:[options(model_option_list)]}
      AS
      ${6:query_statement}
    """

  'DROP TABLE':
    'prefix': 'drop table'
    'body': """
      drop table `${1:project}.${2:dataset}.${3:table}`
    """
  'DROP TABLE IF EXISTS':
    'prefix': 'drop table if exists'
    'body': """
      drop table if exists `${1:project}.${2:dataset}.${3:table}`
    """

  'DROP VIEW':
    'prefix': 'drop view'
    'body': """
      drop view `${1:project}.${2:dataset}.${3:view}`
    """
  'DROP VIEW IF EXISTS':
    'prefix': 'drop view if exists'
    'body': """
      drop view if exists `${1:project}.${2:dataset}.${3:view}`
    """

  'DROP MODEL':
    'prefix': 'drop model'
    'body': """
      ${1:drop model | drop model if exists} `${2:project}.${3:dataset}.${4:model}`
    """

  'ALTER TABLE SET OPTIONS':
    'prefix': 'altertable'
    'body': """
      alter table `${1:project}.${2:dataset}.${3:table}`
      set options (
      \tdescription = "description",
      \texpiration_timestamp = timestamp "YYYY-MM-DD HH:MI:SS UTC",
      \tpartition_expiration_days = 1,
      \trequire_partition_filter = false,
      \tkms_key_name = "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]",
      \tfriendly_name = "friendly_name",
      \tlabels = [("key", "value")]
      )
    """
  'ALTER TABLE IF EXISTS SET OPTIONS':
    'prefix': 'altertableifexists'
    'body': """
      alter table if exists `${1:project}.${2:dataset}.${3:table}`
      set options (
      \tdescription = "description",
      \texpiration_timestamp = timestamp "YYYY-MM-DD HH:MI:SS UTC",
      \tpartition_expiration_days = 1,
      \trequire_partition_filter = false,
      \tkms_key_name = "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]",
      \tfriendly_name = "friendly_name",
      \tlabels = [("key", "value")]
      )
    """

  'ALTER VIEW SET OPTIONS':
    'prefix': 'alterview'
    'body': """
      alter view `${1:project}.${2:dataset}.${3:view}`
      set options (
      \tdescription = "description",
      \texpiration_timestamp = timestamp "YYYY-MM-DD HH:MI:SS UTC",
      \tfriendly_name = "friendly_name",
      \tlabels = [("key", "value")]
      )
    """
  'ALTER VIEW IF EXISTS SET OPTIONS':
    'prefix': 'alterviewifexists'
    'body': """
      alter view if exists `${1:project}.${2:dataset}.${3:view}`
      set options (
      \tdescription = "description",
      \texpiration_timestamp = timestamp "YYYY-MM-DD HH:MI:SS UTC",
      \tfriendly_name = "friendly_name",
      \tlabels = [("key", "value")]
      )
    """

  'CAST()':
    'prefix': 'cast'
    'body': 'cast(${1:expr} as ${2:type})'
    'description': """
      Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.
    """
  'SAFE_CAST()':
    'prefix': 'safe_cast'
    'body': 'safe_cast(${1:expr} as ${2:type})'
    'description': """
      SAFE_CAST is identical to CAST, except it returns NULL instead of raising an error.
    """

  'ANY_VALUE()':
    'prefix': 'any_value'
    'body': 'any_value(${1:expr}) ${2:[over (...)]}'
    'description': """
      Returns any value from the input or NULL if there are zero input rows. The value returned is non-deterministic, which means you might receive a different result each time you use this function.
    """
  'ARRAY_AGG()':
    'prefix': 'array_agg'
    'body': """
      array_agg(${1:[distinct] expression [{ignore|respect\\} nulls]
                [order by key [{asc|desc\\}] [, ... ]] [limit n]})
      ${2:[over (...)]}
    """
    'description': """
      Returns an ARRAY of `expression` values.
    """
  'ARRAY_CONCAT_AGG()':
    'prefix': 'array_concat_agg'
    'body': 'array_concat_agg(${1:expression [order by key [{asc|desc\\}] [, ... ]] [limit n]})'
    'description': """
      Concatenates elements from `expression` of type ARRAY, returning a single ARRAY as a result. This function ignores NULL input arrays, but respects the NULL elements in non-NULL input arrays (an error is raised, however, if an array in the final query result contains a NULL element).
    """
  'AVG()':
    'prefix': 'avg'
    'body': 'avg(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      Returns the average of non-NULL input values, or NaN if the input contains a NaN.
    """
  'BIT_AND()':
    'prefix': 'bit_and'
    'body': 'bit_and(${1:expression})'
    'description': """
      Performs a bitwise AND operation on `expression` and returns the result.
    """
  'BIT_OR()':
    'prefix': 'bit_or'
    'body': 'bit_or(${1:expression})'
    'description': """
      Performs a bitwise OR operation on `expression` and returns the result.
    """
  'BIT_XOR()':
    'prefix': 'bit_xor'
    'body': 'bit_xor(${1:expression})'
    'description': """
      Performs a bitwise XOR operation on `expression` and returns the result.
    """
  'COUNT(*)':
    'prefix': 'count'
    'body': 'count(*)'
    'description': """
      Returns the number of rows in the input.
    """
  'COUNT(expr)':
    'prefix': 'count expr'
    'body': 'count(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      Returns the number of rows with `expression` evaluated to any value other than NULL.
    """
  'COUNTIF()':
    'prefix': 'countif'
    'body': 'countif(${1:expression}) ${2:[over (...)]}'
    'description': """
      Returns the count of TRUE values for `expression`. Returns 0 if there are zero input rows or `expression` evaluates to FALSE for all rows.
    """
  'LOGICAL_AND()':
    'prefix': 'logical_and'
    'body': 'logical_and(${1:expression})'
    'description': """
      Returns the logical AND of all non-NULL expressions. Returns NULL if there are zero input rows or `expression` evaluates to NULL for all rows.
    """
  'LOGICAL_OR()':
    'prefix': 'logical_or'
    'body': 'logical_or(${1:expression})'
    'description': """
      Returns the logical OR of all non-NULL expressions. Returns NULL if there are zero input rows or `expression` evaluates to NULL for all rows.
    """
  'MAX()':
    'prefix': 'max'
    'body': 'max(${1:expression}) ${2:[over (...)]}'
    'description': """
      Returns the maximum value of non-NULL expressions. Returns NULL if there are zero input rows or `expression` evaluates to NULL for all rows. Returns NaN if the input contains a NaN.
    """
  'MIN()':
    'prefix': 'min'
    'body': 'min(${1:expression}) ${2:[over (...)]}'
    'description': """
      Returns the minimum value of non-NULL expressions. Returns NULL if there are zero input rows or `expression` evaluates to NULL for all rows. Returns NaN if the input contains a NaN.
    """
  'STRING_AGG()':
    'prefix': 'string_agg'
    'body': """
      string_agg(${1:[distinct] expression [, delimiter] [order by key [{asc|desc\\}] [, ... ]] [limit n]})
      ${2:[over (...)]}
    """
    'description': """
      Returns a value (either STRING or BYTES) obtained by concatenating non-null values.

      If a `delimiter` is specified, concatenated values are separated by that delimiter; otherwise, a comma is used as a delimiter.
    """
  'SUM()':
    'prefix': 'sum'
    'body': 'sum(${1:expression}) ${2:[over (...)]}'
    'description': """
      Returns the sum of non-null values.

      If the expression is a floating point value, the sum is non-deterministic, which means you might receive a different result each time you use this function.
    """

  'CORR()':
    'prefix': 'corr'
    'body': 'corr(${1:X1}, ${2:X2}) ${3:[over (...)]}'
    'description': """
      Returns the Pearson coefficient of correlation of a set of number pairs. For each number pair, the first number is the dependent variable and the second number is the independent variable. The return result is between `-1` and `1`. A result of `0` indicates no correlation.

      This function ignores any input pairs that contain one or more NULL values. If there are fewer than two input pairs without NULL values, this function returns NULL.
    """
  'COVAR_POP()':
    'prefix': 'covar_pop'
    'body': 'covar_pop(${1:X1}, ${2:X2}) ${3:[over (...)]}'
    'description': """
      Returns the population covariance of a set of number pairs. The first number is the dependent variable; the second number is the independent variable. The return result is between `-Inf` and `+Inf`.

      This function ignores any input pairs that contain one or more NULL values. If there is no input pair without NULL values, this function returns NULL. If there is exactly one input pair without NULL values, this function returns 0.
    """
  'COVAR_SAMP()':
    'prefix': 'covar_samp'
    'body': 'covar_samp(${1:X1}, ${2:X2}) ${3:[over (...)]}'
    'description': """
      Returns the sample covariance of a set of number pairs. The first number is the dependent variable; the second number is the independent variable. The return result is between `-Inf` and `+Inf`.

      This function ignores any input pairs that contain one or more NULL values. If there are fewer than two input pairs without NULL values, this function returns NULL.
    """
  'STDDEV_POP()':
    'prefix': 'stddev_pop'
    'body': 'stddev_pop(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      Returns the population (biased) standard deviation of the values. The return result is between `0` and `+Inf`.

      This function ignores any NULL inputs. If all inputs are ignored, this function returns NULL.

      If this function receives a single non-NULL input, it returns `0`.
    """
  'STDDEV_SAMP()':
    'prefix': 'stddev_samp'
    'body': 'stddev_samp(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      Returns the sample (unbiased) standard deviation of the values. The return result is between `0` and `+Inf`.

      This function ignores any NULL inputs. If there are fewer than two non-NULL inputs, this function returns NULL.
    """
  'STDDEV()':
    'prefix': 'stddev'
    'body': 'stdev(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      An alias of STDDEV_SAMP.
    """
  'VAR_POP()':
    'prefix': 'var_pop'
    'body': 'var_pop(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      Returns the population (biased) variance of the values. The return result is between `0` and `+Inf`.

      This function ignores any NULL inputs. If all inputs are ignored, this function returns NULL.

      If this function receives a single non-NULL input, it returns `0`.
    """
  'VAR_SAMP()':
    'prefix': 'var_samp'
    'body': 'var_samp(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      Returns the sample (unbiased) variance of the values. The return result is between `0` and `+Inf`.

      This function ignores any NULL inputs. If there are fewer than two non-NULL inputs, this function returns NULL.
    """
  'VARIANCE()':
    'prefix': 'variance'
    'body': 'variance(${1:[distinct] expression}) ${2:[over (...)]}'
    'description': """
      An alias of VAR_SAMP.
    """

  'APPROX_COUNT_DISTINCT()':
    'prefix': 'approx_count_distinct'
    'body': 'approx_count_distinct(${1:expression})'
    'description': """
      Returns the approximate result for `COUNT(DISTINCT expression)`. The value returned is a statistical estimate—not necessarily the actual value.

      This function is less accurate than `COUNT(DISTINCT expression)`, but performs better on huge input.
    """
  'APPROX_QUANTILES()':
    'prefix': 'approx_quantiles'
    'body': 'approx_quantiles(${1:[distinct] expression, number [{ignore|respect\\} nulls]})'
    'description': 'Returns the approximate boundaries for a group of `expression` values, where `number` represents the number of quantiles to create. This function returns an array of `number` + 1 elements, where the first element is the approximate minimum and the last element is the approximate maximum.'
  'APPROX_TOP_COUNT()':
    'prefix': 'approx_top_count'
    'body': 'approx_top_count(${1:expression}, ${2:number})'
    'description': 'Returns the approximate top elements of `expression`. The `number` parameter specifies the number of elements returned.'
  'APPROX_TOP_SUM()':
    'prefix': 'approx_top_sum'
    'body': 'approx_top_sum(${1:expression}, ${2:weight}, ${3:number})'
    'description': """
      Returns the approximate top elements of `expression`, based on the sum of an assigned `weight`. The `number` parameter specifies the number of elements returned.

      If the `weight` input is negative or `NaN`, this function returns an error.
    """

  'HLL_COUNT.INIT()':
    'prefix': 'hll_count.init'
    'body': 'hll_count.init(${1:input [, precision]})'
    'description': """
      A scalar function that takes one or more input values and aggregates them into a HyperLogLog++ sketch. Each sketch is represented using the BYTES data type. You can then merge these sketches using HLL_COUNT.MERGE or HLL_COUNT.MERGE_PARTIAL, or if no merging is needed, converted to the final count of distinct values using HLL_COUNT.EXTRACT.
    """
  'HLL_COUNT.MERGE()':
    'prefix': 'hll_count.merge'
    'body': 'hll_count.merge(${1:sketch})'
    'description': """
      An aggregate function that returns the cardinality of several HyperLogLog++ set sketches by computing their union.

      Each `sketch` must have the same precision and be initialized on the same type. Attempts to merge sketches with different precisions or for different types results in an error. For example, you cannot merge a sketch initialized from INT64 data with one initialized from STRING data.

      This function ignores NULL values when merging sketches. If the merge happens over zero rows or only over NULL values, the function returns `0`.
    """
  'HLL_COUNT.MERGE_PARTIAL()':
    'prefix': 'hll_count.merge_partial'
    'body': 'hll_count.merge_partial(${1:sketch})'
    'description': """
      An aggregate function that takes one or more HyperLogLog++ `sketch` inputs and merges them into a new sketch. This function is useful if you want to reduce a table that already contains sketches, but do not yet want to estimate the cardinality. For example, use this function if you want to create a sketch that you will merge further later.

      This function returns NULL if there is no input or all inputs are NULL.
    """
  'HLL_COUNT.EXTRACT()':
    'prefix': 'hll_count.extract'
    'body': 'hll_count.extract(${1:sketch})'
    'description': """
      A scalar function that extracts an cardinality estimate of a single HyperLogLog++ sketch.

      If `sketch` is NULL, this function returns a cardinality estimate of `0`.
    """

  'RANK()':
    'prefix': 'rank'
    'body': 'rank()'
    'description': """
      Returns the ordinal (1-based) rank of each row within the ordered partition. All peer rows receive the same rank value. The next row or set of peer rows receives a rank value which increments by the number of peers with the previous rank value, instead of a rank value which always increments by 1. See example of `RANK()` below this table.
    """
  'DENSE_RANK()':
    'prefix': 'dense_rank'
    'body': 'dense_rank()'
    'description': """
      Returns the ordinal (1-based) rank of each row within the window partition. All peer rows receive the same rank value, and the subsequent rank value is incremented by one.
    """
  'PERCENT_RANK()':
    'prefix': 'percent_rank'
    'body': 'percent_rank()'
    'description': """
      Return the percentile rank of a row defined as (RK-1)/(NR-1), where RK is the `RANK` of the row and NR is the number of rows in the partition. Returns 0 if NR=1.
    """
  'CUME_DIST()':
    'prefix': 'cume_dist'
    'body': 'cume_dist()'
    'description': """
      Return the relative rank of a row defined as NP/NR. NP is defined to be the number of rows that either precede or are peers with the current row. NR is the number of rows in the partition.
    """
  'NTILE()':
    'prefix': 'ntile'
    'body': 'ntile(${1:constant_integer_expression})'
    'description': """
      This function divides the rows into `constant_integer_expression` buckets based on row ordering and returns the 1-based bucket number that is assigned to each row. The number of rows in the buckets can differ by at most 1. The remainder values (the remainder of number of rows divided by buckets) are distributed one for each bucket, starting with bucket 1. If `constant_integer_expression` evaluates to NULL, 0 or negative, an error is provided.
    """
  'ROW_NUMBER()':
    'prefix': 'row_number'
    'body': 'row_number()'
    'description': """
      Does not require the `ORDER BY` clause. Returns the sequential row ordinal (1-based) of each row for each ordered partition. If the `ORDER BY` clause is unspecified then the result is non-deterministic.
    """
  'FIRST_VALUE()':
    'prefix': 'first_value'
    'body': 'first_value(${1:value_expression [{respect | ignore\\} nulls]})'
    'description': """
      Returns the value of the `value_expression` for the first row in the current window frame.

      This function includes `NULL` values in the calculation unless `IGNORE NULLS` is present. If `IGNORE NULLS` is present, the function excludes `NULL` values from the calculation.
    """
  'LAST_VALUE()':
    'prefix': 'last_value'
    'body': 'last_value(${1:value_expression [{respect | ignore\\} nulls]})'
    'description': """
      Returns the value of the `value_expression` for the last row in the current window frame.

      This function includes `NULL` values in the calculation unless `IGNORE NULLS` is present. If `IGNORE NULLS` is present, the function excludes `NULL` values from the calculation.
    """
  'NTH_VALUE()':
    'prefix': 'nth_value'
    'body': 'nth_value(${1:value_expression, constant_integer_expression [{respect | ignore\\} nulls]})'
    'description': """
      Returns the value of `value_expression` at the Nth row of the current window frame, where Nth is defined by `constant_integer_expression`. Returns NULL if there is no such row.

      This function includes `NULL` values in the calculation unless `IGNORE NULLS` is present. If `IGNORE NULLS` is present, the function excludes `NULL` values from the calculation.
    """
  'LEAD()':
    'prefix': 'lead'
    'body': 'lead(${1:value_expression, [, offset [, default_expression]]})'
    'description': """
      Returns the value of the `value_expression` on a subsequent row. Changing the `offset` value changes which subsequent row is returned; the default value is `1`, indicating the next row in the window frame. An error occurs if `offset` is `NULL` or a negative value.

      The optional `default_expression` is used if there isn't a row in the window frame at the specified offset. This expression must be a constant expression and its type must be implicitly `coercible` to the type of `value_expression`. If left unspecified, `default_expression` defaults to `NULL`.
    """
  'LAG()':
    'prefix': 'lag'
    'body': 'lag(${1:value_expression, [, offset [, default_expression]]})'
    'description': """
      Returns the value of the `value_expression` on a preceding row. Changing the `offset` value changes which preceding row is returned; the default value is `1`, indicating the previous row in the window frame. An error occurs if `offset` is NULL or a negative value.

      The optional `default_expression` is used if there isn't a row in the window frame at the specified offset. This expression must be a constant expression and its type must be implicitly `coercible` to the type of `value_expression`. If left unspecified, `default_expression` defaults to `NULL`.
    """
  'PERCENTILE_CONT()':
    'prefix': 'percentile_cont'
    'body': 'percentile_cont(${1:value_expression, percentile [{respect | ignore\\} nulls]})'
    'description': """
      Computes the specified percentile value for the value_expression, with linear interpolation.

      This function ignores NULL values if `RESPECT NULLS` is absent. If `RESPECT NULLS` is present:

        * Interpolation between two `NULL` values returns `NULL`.
        * Interpolation between a `NULL` value and a non-`NULL` value returns the non-`NULL` value.
    """
  'PERCENTILE_DISC()':
    'prefix': 'percentile_disc'
    'body': 'percentile_disc(${1:value_expression, percentile [{respect | ignore\\} nulls]})'
    'description': """
      Computes the specified percentile value for a discrete `value_expression`. The returned value is the first sorted value of `value_expression` with cumulative distribution greater than or equal to the given `percentile` value.

      This function ignores `NULL` values unless `RESPECT NULLS` is present.
    """

  'BIT_COUNT()':
    'prefix': 'bit_count'
    'body': 'bit_count(${1:expression})'
    'description': """
      The input, `expression`, must be an integer or BYTES.

      Returns the number of bits that are set in the input `expression`. For integers, this is the number of bits in two's complement form.
    """

  'ABS()':
    'prefix': 'abs'
    'body': 'abs(${1:X})'
    'description': """
      Computes absolute value. With integer argument, generates an error if the value cannot be represented as the same type (which happens only for the largest negative input value, which has no positive representation). Returns `+inf` for `+/-inf` argument.
    """
  'SIGN()':
    'prefix': 'sign'
    'body': 'sign(${1:X})'
    'description': """
      Returns -1, 0, or +1 for negative, zero and positive argument respectively. With floating point argument does not distinguish positive and negative zero. Returns `NaN` for `NaN` argument.
    """
  'IS_INF()':
    'prefix': 'is_inf'
    'body': 'is_inf(${1:X})'
    'description': """
      Return TRUE if the value is positive or negative infinity. Returns `NULL` for `NULL` inputs.
    """
  'IS_NAN()':
    'prefix': 'is_nan'
    'body': 'is_nan(${1:X})'
    'description': """
      Return TRUE if the value is a `NaN` value. Returns `NULL` for `NULL` inputs.
    """
  'IEEE_DIVIDE()':
    'prefix': 'ieee_divide'
    'body': 'ieee_divide(${1:X}, ${2:Y})'
    'description': """
      Divides X by Y; never fails. Returns FLOAT64. Unlike division operator (/), does not generate errors for division by zero or overflow.

      Special cases:

        * If the result overflows, returns `+/-inf`.
        * If Y=0 and X=0, returns NaN.
        * If Y=0 and X!=0, returns `+/-inf`.
        * If X = `+/-inf` and Y = `+/-inf`, returns `NaN`.

      The behavior of IEEE_DIVIDE is further illustrated in the table below.
    """
  'RAND()':
    'prefix': 'rand'
    'body': 'rand()'
    'description': """
      Generates a pseudo-random value of type FLOAT64 in the range of [0, 1), inclusive of 0 and exclusive of 1.
    """
  'SQRT()':
    'prefix': 'sqrt'
    'body': 'sqrt(${1:X})'
    'description': """
      Computes the square root of X. Generates an error if X less than 0. Returns `+inf` if X is `+inf`.
    """
  'POW()':
    'prefix': 'pow'
    'body': 'pow(${1:X}, ${2:Y})'
    'description': """
      Power function: returns the value of X raised to the power of Y. If the result underflows and is not representable then zero value is returned. An error can be generated if one of the following is true:X is a finite value less than 0 and Y is a noninteger,if X is 0, and Y is a finite value less than 0,the result overflows.The behavior of POW() is further illustrated in the table below.
    """
  'POWER()':
    'prefix': 'power'
    'body': 'power(${1:X}, ${2:Y})'
    'description': """
      Synonym of POW(). The behavior of POWER() is further illustrated in the table below.
    """
  'EXP()':
    'prefix': 'exp'
    'body': 'exp(${1:X})'
    'description': """
      Computes natural exponential function ex. If the result underflows a zero is returned. Generates an error if the result overflows. If X is `+/-inf`, then `+inf` (or 0) is returned.
    """
  'LN()':
    'prefix': 'ln'
    'body': 'ln(${1:X})'
    'description': """
      Computes the natural logarithm of X. Generates an error if X is less or equal zero. If X is `+inf`, then `+inf` is returned.
    """
  'LOG(X)':
    'prefix': 'logln'
    'body': 'logln(${1:X})'
    'description': """
      Synonym of LN(X)
    """
  'LOG(X, Y)':
    'prefix': 'log'
    'body': 'log(${1:X}, ${2:Y})'
    'description': """
      Computes logarithm of X to base Y. Generates an error if:X less or equal zero,Y is 1.0,Y less or equal zero.The behavior of LOG(X, Y) is further illustrated in the table below.
    """
  'LOG10()':
    'prefix': 'log10'
    'body': 'log10(${1:X})'
    'description': """
      Similar to LOG(X) but computes logarithm to base 10.
    """
  'GREATEST()':
    'prefix': 'greatest'
    'body': 'greatest(${1:X1,...,XN})'
    'description': """
      Returns `NULL` if any of the inputs is `NULL`. Otherwise, returns `NaN` if any of the inputs is `NaN`. Otherwise, returns the largest value among X1,...,XN according to the < comparison.
    """
  'LEAST()':
    'prefix': 'least'
    'body': 'least(${1:X1,...,XN})'
    'description': """
      Returns `NULL` if any of the inputs is `NULL`. Otherwise, returns `NaN` if any of the inputs is `NaN`. Otherwise, returns the smallest value among X1,...,XN according to the > comparison.
    """
  'DIV()':
    'prefix': 'div'
    'body': 'div(${1:X}, ${2:Y})'
    'description': """
      Returns the result of integer division of X by Y. Division by zero returns an error. Division by -1 may overflow. See the table below for possible result types.
    """
  'SAFE_DIVIDE()':
    'prefix': 'safe_divide'
    'body': 'safe_divide(${1:X}, ${2:Y})'
    'description': """
      Equivalent to the division operator (`/`). Returns `NULL` if an error occurs, such as division by zero.
    """
  'MOD()':
    'prefix': 'mod'
    'body': 'mod(${1:X}, ${2:Y})'
    'description': """
      Modulo function: returns the remainder of the division of X by Y. Returned value has the same sign as X. An error is generated if Y is 0. See the table below for possible result types.
    """

  'COS()':
    'prefix': 'cos'
    'body': 'cos(${1:X})'
    'description': """
      Computes cosine of X. Never fails.
    """
  'COSH()':
    'prefix': 'cosh'
    'body': 'cosh(${1:X})'
    'description': """
      Computes the hyperbolic cosine of X. Generates an error if an overflow occurs.
    """
  'ACOS()':
    'prefix': 'acos'
    'body': 'acos(${1:X})'
    'description': """
      Computes the principal value of the arc cosine of X. The return value is in the range [0,]. Generates an error if X is a finite value outside of range [-1, 1].
    """
  'ACOSH()':
    'prefix': 'acosh'
    'body': 'acosh(${1:X})'
    'description': """
      Computes the inverse hyperbolic cosine of X. Generates an error if X is a finite value less than 1.
    """
  'SIN()':
    'prefix': 'sin'
    'body': 'sin(${1:X})'
    'description': """
      Computes the sine of X. Never fails.
    """
  'SINH()':
    'prefix': 'sinh'
    'body': 'SINH(${1:X})'
    'description': """
      Computes the hyperbolic sine of X. Generates an error if an overflow occurs.
    """
  'ASIN()':
    'prefix': 'asin'
    'body': 'asin(${1:X})'
    'description': """
      Computes the principal value of the arc sine of X. The return value is in the range [-π/2,π/2]. Generates an error if X is a finite value outside of range [-1, 1].
    """
  'ASINH()':
    'prefix': 'asinh'
    'body': 'asinh(${1:X})'
    'description': """
      Computes the inverse hyperbolic sine of X. Does not fail.
    """
  'TAN()':
    'prefix': 'tan'
    'body': 'tan(${1:X})'
    'description': """
      Computes tangent of X. Generates an error if an overflow occurs.
    """
  'TANH()':
    'prefix': 'tanh'
    'body': 'tanh(${1:X})'
    'description': """
      Computes hyperbolic tangent of X. Does not fail.
    """
  'ATAN()':
    'prefix': 'atan'
    'body': 'atan(${1:X})'
    'description': """
      Computes the principal value of the arc tangent of X. The return value is in the range [-π/2,π/2]. Does not fail.
    """
  'ATANH()':
    'prefix': 'atanh'
    'body': 'atanh(${1:X})'
    'description': """
      Computes the inverse hyperbolic tangent of X. Generates an error if the absolute value of X is greater or equal 1.
    """
  'ATAN2()':
    'prefix': 'atan2'
    'body': 'atan2(${1:X}, ${2:Y})'
    'description': """
      Calculates the principal value of the arc tangent of Y/X using the signs of the two arguments to determine the quadrant. The return value is in the range [-π,π]. The behavior of this function is further illustrated in the table below.
    """

  'FARM_FINGERPRINT()':
    'prefix': 'farm_fingerprint'
    'body': 'farm_fingerprint(${1:value})'
    'type': 'function'
    'description': """
      Computes the fingerprint of the STRING or BYTES input using the Fingerprint64 function from the open-source FarmHash library. The output of this function for a particular input will never change.
    """
  'MD5()':
    'prefix': 'md5'
    'body': 'md5(${1:input})'
    'description': """
      Computes the hash of the input using the MD5 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

      This function returns 16 bytes.
    """
  'SHA1()':
    'prefix': 'sha1'
    'body': 'sha1(${1:input})'
    'description': """
      Computes the hash of the input using the SHA-1 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

      This function returns 20 bytes.
    """
  'SHA256()':
    'prefix': 'sha256'
    'body': 'sha256(${1:input})'
    'description': """
      Computes the hash of the input using the SHA-256 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

      This function returns 32 bytes.
    """
  'SHA512()':
    'prefix': 'sha512'
    'body': 'sha512(${1:input})'
    'description': """
      Computes the hash of the input using the SHA-512 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

      This function returns 64 bytes.
    """

  'BYTE_LENGTH()':
    'prefix': 'byte_length'
    'body': 'byte_length(${1:value})'
    'description': """
      Returns the length of the value in bytes, regardless of whether the type of the value is STRING or BYTES.
    """
  'CHAR_LENGTH()':
    'prefix': 'char_length'
    'body': 'char_length(${1:value})'
    'description': """
      Returns the length of the STRING in characters.
    """
  'CHARACTER_LENGTH()':
    'prefix': 'character_length'
    'body': 'character_length(${1:value})'
    'description': """
      Synonym for CHAR_LENGTH.
    """
  'CODE_POINTS_TO_BYTES()':
    'prefix': 'code_points_to_bytes'
    'body': 'code_points_to_bytes(${1:ascii_values})'
    'description': """
      Takes an array of extended ASCII code points (ARRAY of INT64) and returns BYTES.

      To convert from BYTES to an array of code points, see TO_CODE_POINTS.
    """
  'CODE_POINTS_TO_STRING()':
    'prefix': 'code_points_to_string'
    'body': 'code_points_to_string(${1:value})'
    'description': """
      Takes an array of Unicode code points (ARRAY of INT64) and returns a STRING.

      To convert from a string to an array of code points, see TO_CODE_POINTS.
    """
  'CONCAT()':
    'prefix': 'concat'
    'body': 'concat(${1:value1[, ...]})'
    'description': """
      Concatenates one or more values into a single result.
    """
  'ENDS_WITH()':
    'prefix': 'ends_with'
    'body': 'ends_with(${1:value1}, ${2:value2})'
    'description': """
      Takes two values. Returns TRUE if the second value is a suffix of the first.
    """
  'FORMAT()':
    'prefix': 'format'
    'body': 'format(${1:<format_string>, ...})'
    'description': """
      BigQuery supports a FORMAT() function for formatting strings. This function is similar to the C printf function. It produces a STRING from a format string that contains zero or more format specifiers, along with a variable length list of additional arguments that matches the format specifiers.
    """
  'FROM_BASE32()':
    'prefix': 'from_base32'
    'body': 'from_base32(${1:string_expr})'
    'description': """
      Converts the base32-encoded input `string_expr` into BYTES format. To convert BYTES to a base32-encoded STRING, use TO_BASE32.
    """
  'FROM_BASE64()':
    'prefix': 'from_base64'
    'body': 'from_base64(${1:string_expr})'
    'description': """
      Converts the base64-encoded input `string_expr` into BYTES format. To convert BYTES to a base64-encoded STRING, use TO_BASE64.
    """
  'FROM_HEX()':
    'prefix': 'from_hex'
    'body': 'from_hex(${1:string})'
    'description': """
      Converts a hexadecimal-encoded STRING into BYTES format. Returns an error if the input STRING contains characters outside the range (0..9, A..F, a..f). The lettercase of the characters does not matter. To convert BYTES to a hexadecimal-encoded STRING, use TO_HEX.
    """
  'LENGTH()':
    'prefix': 'length'
    'body': 'length(${1:value})'
    'description': """
      Returns the length of the value. The returned value is in characters for STRING arguments and in bytes for the BYTES argument.
    """
  'LPAD()':
    'prefix': 'lpad'
    'body': 'lpad(${1:original_value}, ${2:return_length[, pattern]})'
    'description': """
      Returns a value that consists of `original_value` prepended with `pattern`. The `return_length` is an INT64 that specifies the length of the returned value. If `original_value` is BYTES, `return_length` is the number of bytes. If `original_value` is STRING, `return_length` is the number of characters.

      The default value of `pattern` is a blank space.
    """
  'LOWER()':
    'prefix': 'lower'
    'body': 'lower(${1:value})'
    'description': """
      For STRING arguments, returns the original string with all alphabetic characters in lowercase. Mapping between lowercase and uppercase is done according to the Unicode Character Database without taking into account language-specific mappings.

      For BYTES arguments, the argument is treated as ASCII text, with all bytes greater than 127 left intact.
    """
  'LTRIM()':
    'prefix': 'ltrim'
    'body': 'ltrim(${1:value1[, value2]})'
    'description': """
      Identical to TRIM, but only removes leading characters.
    """
  'NORMALIZE()':
    'prefix': 'normalize'
    'body': 'normalize(${1:value[, normalization_mode]})'
    'description': """
      Takes a STRING, `value`, and returns it as a normalized string.

      Normalization is used to ensure that two strings are equivalent. Normalization is often used in situations in which two strings render the same on the screen but have different Unicode code points.
    """
  'NORMALIZE_AND_CASEFOLD()':
    'prefix': 'normalize_and_casefold'
    'body': 'normalize_and_casefold(${1:value[, normalization_mode]})'
    'description': """
      Takes a STRING, `value`, and performs the same actions as NORMALIZE, as well as casefolding for case-insensitive operations.
    """
  'REGEXP_CONTAINS()':
    'prefix': 'regexp_contains'
    'body': 'regexp_contains(${1:value}, r"${2:regex}")'
    'description': """
      Returns TRUE if `value` is a partial match for the regular expression, `regex`. You can search for a full match by using ^ (beginning of text) and $ (end of text).

      If the `regex` argument is invalid, the function returns an error.

      Note: BigQuery provides regular expression support using the `re2` library; see that documentation for its regular expression syntax.
    """
  'REGEXP_EXTRACT()':
    'prefix': 'regexp_extract'
    'body': 'regexp_extract(${1:value}, r"${2:regex}")'
    'description': """
      Returns the first substring in `value` that matches the regular expression, `regex`. Returns NULL if there is no match.

      Note: BigQuery provides regular expression support using the `re2` library; see that documentation for its regular expression syntax.
    """
  'REGEXP_EXTRACT_ALL()':
    'prefix': 'regexp_extract_all'
    'body': 'regexp_extract_all(${1:value}, r"${2:regex}")'
    'description': """
      Returns an array of all substrings of `value` that match the regular expression, `regex`.

      The `REGEXP_EXTRACT_ALL` function only returns non-overlapping matches. For example, using this function to extract `ana` from `banana` returns only one substring, not two.

      Note: BigQuery provides regular expression support using the `re2` library; see that documentation for its regular expression syntax.
    """
  'REGEXP_REPLACE()':
    'prefix': 'regexp_replace'
    'body': 'regexp_replace(${1:value}, r"${2:regex}", ${3:replacement})'
    'description': """
      Returns a STRING where all substrings of `value` that match regular expression `regex` are replaced with `replacement`.

      Note: BigQuery provides regular expression support using the `re2` library; see that documentation for its regular expression syntax.
    """
  'REPLACE()':
    'prefix': 'replace'
    'body': 'replace(${1:original_value}, ${2:from_value}, ${3:to_value})'
    'description': """
      Replaces all occurrences of `from_value` with `to_value` in `original_value`. If from_value is empty, no replacement is made.
    """
  'REPEAT()':
    'prefix': 'repeat'
    'body': 'repeat(${1:original_value}, ${2:repetitions})'
    'description': """
      Returns a value that consists of `original_value`, repeated. The `repetitions` parameter specifies the number of times to repeat `original_value`. Returns NULL if either `original_value` or `repetitions` are NULL.

      This function return an error if the `repetitions` value is negative.
    """
  'REVERSE()':
    'prefix': 'reverse'
    'body': 'reverse(${1:value})'
    'description': """
      Returns the reverse of the input STRING or BYTES.
    """
  'RPAD()':
    'prefix': 'rpad'
    'body': 'rpad(${1:original_value}, ${2:return_length[, pattern]})'
    'description': """
      Returns a value that consists of `original_value` appended with pattern. The `return_length` is an INT64 that specifies the length of the returned value. If `original_value` is BYTES, `return_length` is the number of bytes. If `original_value` is STRING, `return_length` is the number of characters.

      The default value of `pattern` is a blank space.
    """
  'RTRIM()':
    'prefix': 'rtrim'
    'body': 'rtrim(${1:value1[, value2]})'
    'description': """
      Identical to TRIM, but only removes trailing characters.
    """
  'SAFE_CONVERT_BYTES_TO_STRING()':
    'prefix': 'safe_convert_bytes_to_string'
    'body': 'safe_convert_bytes_to_string(${1:value})'
    'description': """
      Converts a sequence of bytes to a string. Any invalid UTF-8 characters are replaced with the Unicode replacement character, `U+FFFD`.
    """
  'SPLIT()':
    'prefix': 'split'
    'body': 'split(${1:value[, delimiter]})'
    'description': """
      Splits `value` using the `delimiter` argument.

      For STRING, the default delimiter is the comma `,`.

      For BYTES, you must specify a delimiter.

      Splitting on an empty delimiter produces an array of UTF-8 characters for STRING values, and an array of BYTES for BYTES values.

      Splitting an empty STRING returns an ARRAY with a single empty STRING.
    """
  'STARTS_WITH()':
    'prefix': 'starts_with'
    'body': 'starts_with(${1:value1}, ${2:value2})'
    'description': """
      Takes two values. Returns TRUE if the second value is a prefix of the first.
    """
  'STRPOS()':
    'prefix': 'strpos'
    'body': 'strpos(${1:string}, ${2:substring})'
    'description': """
      Returns the 1-based index of the first occurrence of `substring` inside `string`. Returns 0 if `substring` is not found.
    """
  'SUBSTR()':
    'prefix': 'substr'
    'body': 'substr(${1:value}, ${2:position[, length]})'
    'description': """
      Returns a substring of the supplied `value`. The `position` argument is an integer specifying the starting position of the substring, with position = 1 indicating the first character or byte. The `length` argument is the maximum number of characters for STRING arguments, or bytes for BYTES arguments.

      If `position` is negative, the function counts from the end of `value`, with -1 indicating the last character.
    """
  'TO_BASE32()':
    'prefix': 'to_base32'
    'body': 'to_base32(${1:bytes_expr})'
    'description': """
      Converts a sequence of BYTES into a base32-encoded STRING. To convert a base32-encoded STRING into BYTES, use FROM_BASE32.
    """
  'TO_BASE64()':
    'prefix': 'to_base64'
    'body': 'to_base64(${1:bytes_expr})'
    'description': """
      Converts a sequence of BYTES into a base64-encoded STRING. To convert a base64-encoded STRING into BYTES, use FROM_BASE64.
    """
  'TO_CODE_POINTS()':
    'prefix': 'to_code_points'
    'body': 'to_code_points(${1:value})'
    'description': """
      Takes a value and returns an array of INT64.

      To convert from an array of code points to a STRING or BYTES, see CODE_POINTS_TO_STRING or CODE_POINTS_TO_BYTES.
    """
  'TO_HEX()':
    'prefix': 'to_hex'
    'body': 'to_hex(${1:bytes})'
    'description': """
      Converts a sequence of BYTES into a hexadecimal STRING. Converts each byte in the STRING as two hexadecimal characters in the range (0..9, a..f). To convert a hexadecimal-encoded STRING to BYTES, use FROM_HEX.
    """
  'TRIM()':
    'prefix': 'trim'
    'body': 'trim(${1:value1[, value2]})'
    'description': """
      Removes all leading and trailing characters that match `value2`. If `value2` is not specified, all leading and trailing whitespace characters (as defined by the Unicode standard) are removed. If the first argument is of type BYTES, the second argument is required.
    """
  'UPPER()':
    'prefix': 'upper'
    'body': 'upper(${1:value})'
    'description': """
      For STRING arguments, returns the original string with all alphabetic characters in uppercase. Mapping between uppercase and lowercase is done according to the Unicode Character Database without taking into account language-specific mappings.

      For BYTES arguments, the argument is treated as ASCII text, with all bytes greater than 127 left intact.
    """

  'JSON_EXTRACT()':
    'prefix': 'json_extract'
    'body': 'json_extract(${1:json_string_expr}, ${2:json_path_string_literal})'
    'description': """
      Which returns JSON values as STRINGs.
    """
  'JSON_EXTRACT_SCALAR()':
    'prefix': 'json_extract_scalar'
    'body': 'json_extract_scalar(${1:json_string_expr}, ${2:json_path_string_literal})'
    'description': """
      Which returns scalar JSON values as STRINGs.
    """
  'TO_JSON_STRING()':
    'prefix': 'to_json_string'
    'body': 'to_json_string(${1:value[, pretty_print]})'
    'description': """
      Returns a JSON-formatted string representation of `value`. This function supports an optional `pretty_print` parameter. If `pretty_print` is present, the returned value is formatted for easy readability.
    """

  'ARRAY_CONCAT()':
    'prefix': 'array_concat'
    'body': 'array_concat(${1:array_expression_1 [, array_expression_n]})'
    'description': """
      Concatenates one or more arrays with the same element type into a single array.
    """
  'ARRAY_LENGTH()':
    'prefix': 'array_length'
    'body': 'array_length(${1:array_expression})'
    'description': """
      Returns the size of the array. Returns 0 for an empty array. Returns `NULL` if the `array_expression` is `NULL`.
    """
  'ARRAY_TO_STRING()':
    'prefix': 'array_to_string'
    'body': 'array_to_string(${1:array_expression}, ${2:delimiter[, null_text]})'
    'description': """
      Returns a concatenation of the elements in `array_expression` as a STRING. The value for `array_expression` can either be an array of STRING or BYTES data types.

      If the `null_text` parameter is used, the function replaces any `NULL` values in the array with the value of `null_text`.

      If the `null_text` parameter is not used, the function omits the `NULL` value and its preceding delimiter.
    """
  'GENERATE_ARRAY()':
    'prefix': 'generate_array'
    'body': 'generate_array(${1:start_expression})'
    'description': """
      Returns an array of values. The `start_expression` and `end_expression` parameters determine the inclusive start and end of the array.

      The GENERATE_ARRAY function accepts the following data types as inputs:

        * FLOAT64
        * INT64

      The `step_expression` parameter determines the increment used to generate array values. The default value for this parameter is `1`.

      This function returns an error if `step_expression` is set to 0, or if any input is NaN.

      If any argument is NULL, the function will return a NULL array.
    """
  'GENERATE_DATE_ARRAY()':
    'prefix': 'generate_date_array'
    'body': 'generate_date_array(${1:start_date}, ${2:end_date[, interval INT64_expr date_part]})'
    'description': """
      Returns an array of dates. The `start_date` and `end_date` parameters determine the inclusive start and end of the array.

      The GENERATE_DATE_ARRAY function accepts the following data types as inputs:

        `start_date` must be a DATE
        `end_date` must be a DATE
        `INT64_expr` must be an INT64
        `date_part` must be either DAY, WEEK, MONTH, QUARTER, or YEAR.

      The `INT64_expr` parameter determines the increment used to generate dates. The default value for this parameter is 1 day.

      This function returns an error if `INT64_expr` is set to 0.
    """
  'GENERATE_TIMESTAMP_ARRAY()':
    'prefix': 'generate_timestamp_array'
    'body': 'generate_timestamp_array(${1:start_timestamp}, ${2:end_timestamp[, interval step_expression date_part]})'
    'description': """
      Returns an `ARRAY` of `TIMESTAMPS` separated by a given interval. The `start_timestamp` and `end_timestamp` parameters determine the inclusive lower and upper bounds of the `ARRAY`.

      The GENERATE_TIMESTAMP_ARRAY function accepts the following data types as inputs:

        * `start_timestamp`: TIMESTAMP
        * `end_timestamp`: TIMESTAMP
        * `step_expression`: INT64
        * Allowed date_part values are MICROSECOND, MILLISECOND, SECOND, MINUTE, HOUR, or DAY.

      The step_expression parameter determines the increment used to generate timestamps.
    """
  '[OFFSET(zero_based_offset)]':
    'prefix': 'offset'
    'body': 'offset(${1:zero_based_offset})'
    'description': """
      Accesses an ARRAY element by position and returns the element. `OFFSET` means that the numbering starts at zero, `ORDINAL` means that the numbering starts at one.
    """
  '[ORDINAL(one_based_offset)]':
    'prefix': 'ordinal'
    'body': 'ordinal(${1:one_based_offset})'
    'description': """
      Accesses an ARRAY element by position and returns the element. `OFFSET` means that the numbering starts at zero, `ORDINAL` means that the numbering starts at one.
    """
  'ARRAY_REVERSE()':
    'prefix': 'array_reverse'
    'body': 'array_reverse(${1:value})'
    'description': """
      Returns the input ARRAY with elements in reverse order.
    """
  '[SAFE_OFFSET(zero_based_offset)]':
    'prefix': 'safe_offset'
    'body': 'safe_offset(${1:zero_based_offset})'
    'description': """
      Identical to `OFFSET` and `ORDINAL`, except returns `NULL` if the index is out of range.
    """
  '[SAFE_ORDINAL(one_based_offset)]':
    'prefix': 'safe_ordinal'
    'body': 'safe_ordinal(${1:one_based_offset})'
    'description': """
      Identical to `OFFSET` and `ORDINAL`, except returns `NULL` if the index is out of range.
    """

  'CURRENT_DATE()':
    'prefix': 'current_date'
    'body': 'current_date(${1:[time_zone]})'
    'description': """
      Returns the current date as of the specified or default timezone.

      This function supports an optional `time_zone` parameter. This parameter is a string representing the timezone to use. If no timezone is specified, the default timezone, UTC, is used. See Timezone definitions for information on how to specify a time zone.

      If the `time_zone` parameter evaluates to `NULL`, this function returns `NULL`.
    """
  'EXTRACT(part FROM date_expression)':
    'prefix': 'extract date'
    'body': 'extract(${1:part} from ${2:date_expression})'
    'description': """
      Returns the value corresponding to the specified date part. The `part` must be one of:

        * `DAYOFWEEK`: Returns values in the range [1,7] with Sunday as the first day of the week.
        * `DAY`
        * `DAYOFYEAR`
        * `WEEK`: Returns the week number of the date in the range [0, 53]. Weeks begin with Sunday, and dates prior to the first Sunday of the year are in week 0.
        * `WEEK(<WEEKDAY>)`: Returns the week number of the date in the range [0, 53]. Weeks begin on `WEEKDAY`. Dates prior to the first `WEEKDAY` of the year are in week 0. Valid values for `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and `SATURDAY`.
        * `ISOWEEK`: Returns the ISO 8601 week number of the `date_expression`. `ISOWEEK`s begin on Monday. Return values are in the range [1, 53]. The first `ISOWEEK` of each ISO year begins on the Monday before the first Thursday of the Gregorian calendar year.
        * `MONTH`
        * `QUARTER`: Returns values in the range [1,4].
        * `YEAR`
        * `ISOYEAR`: Returns the ISO 8601 week-numbering year, which is the Gregorian calendar year containing the Thursday of the week to which `date_expression` belongs.
    """
  'DATE(year, month, day)':
    'prefix': 'date use INT'
    'body': 'date(${1:year}, ${2:month}, ${3:day})'
    'description': """
      Constructs a `DATE` from `INT64` values representing the year, month, and day.
    """
  'DATE(timestamp)':
    'prefix': 'date use TIMESTAMP'
    'body': 'date(${1:timestamp_expression[, timezone]})'
    'description': """
      Converts a `timestamp_expression` to a `DATE` data type. It supports an optional parameter to specify a timezone. If no timezone is specified, the default timezone, UTC, is used.
    """
  'DATE_ADD()':
    'prefix': 'date_add'
    'body': 'date_add(${1:date_expression}, interval ${2:INT64_expr date_part})'
    'description': """
      Adds a specified time interval to a DATE.

      DATE_ADD supports the following `date_part` values:

        * `DAY`
        * `WEEK`. Equivalent to 7 DAYs.
        * `MONTH`
        * `QUARTER`
        * `YEAR`

      Special handling is required for MONTH, QUARTER, and YEAR parts when the date is at (or near) the last day of the month. If the resulting month has fewer days than the original date's day, then the result day is the last day of the new month.
    """
  'DATE_SUB()':
    'prefix': 'date_sub'
    'body': 'date_sub(${1:date_expression}, interval ${2:INT64_expr date_part})'
    'description': """
      Subtracts a specified time interval from a DATE.

      DATE_SUB supports the following `date_part` values:

        * `DAY`
        * `WEEK`. Equivalent to 7 DAYs.
        * `MONTH`
        * `QUARTER`
        * `YEAR`

      Special handling is required for MONTH, QUARTER, and YEAR parts when the date is at (or near) the last day of the month. If the resulting month has fewer days than the original date's day, then the result day is the last day of the new month.
    """
  'DATE_DIFF()':
    'prefix': 'date_diff'
    'body': 'date_diff(${1:date_expression}, ${2:date_expression}, ${3:date_part})'
    'description': """
      Returns the number of `date_part` boundaries between the two `date_expression`s. If the first date occurs before the second date, then the result is non-positive.

      DATE_DIFF supports the following `date_part` values:

        * `DAY`
        * `WEEK` This date part begins on Sunday.
        * `ISOWEEK`: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
        * `MONTH`
        * `QUARTER`
        * `YEAR`
        * `ISOYEAR`: Uses the ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.
    """
  'DATE_TRUNC()':
    'prefix': 'date_trunc'
    'body': 'date_trunc(${1:date_expression}, ${2:date_part})'
    'description': """
      Truncates the date to the specified granularity.

      DATE_TRUNC supports the following values for `date_part`:

        * `DAY`
        * `WEEK`
        * `WEEK(<WEEKDAY>)`: Truncates `date_expression` to the preceding week boundary, where weeks begin on WEEKDAY. Valid values for `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and `SATURDAY`.
        * `ISOWEEK`: Truncates `date_expression` to the preceding ISO 8601 week boundary. `ISOWEEK`s begin on Monday. The first `ISOWEEK` of each ISO year contains the first Thursday of the corresponding Gregorian calendar year. Any `date_expression` earlier than this will truncate to the preceding Monday.
        * `MONTH`
        * `QUARTER`
        * `YEAR`
        * `ISOYEAR`: Truncates `date_expression` to the preceding ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.
    """
  'DATE_FROM_UNIX_DATE()':
    'prefix': 'date_from_unix_date'
    'body': 'date_from_unix_date(${1:INT64_expression})'
    'description': """
      Interprets `INT64_expression` as the number of days since 1970-01-01.
    """
  'FORMAT_DATE()':
    'prefix': 'format_date'
    'body': 'format_date(${1:format_string}, ${2:date_expr})'
    'description': """
      Formats the `date_expr` according to the specified `format_string`.

      See Supported Format Elements For DATE for a list of format elements that this function supports.
    """
  'PARSE_DATE()':
    'prefix': 'parse_date'
    'body': 'parse_date(${1:format_string}, ${2:date_string})'
    'description': """
      Uses a `format_string` and a string representation of a date to return a DATE object.

      When using PARSE_DATE, keep the following in mind:

        * Unspecified fields. Any unspecified field is initialized from `1970-01-01`.
        * Case insensitive names. Names, such as `Monday`, `February`, and so on, are case insensitive.
        * Whitespace. One or more consecutive white spaces in the format string matches zero or more consecutive white spaces in the date string. In addition, leading and trailing white spaces in the date string are always allowed -- even if they are not in the format string.
        * Format precedence. When two (or more) format elements have overlapping information (for example both `%F` and `%Y` affect the year), the last one generally overrides any earlier ones.

      See Supported Format Elements For DATE for a list of format elements that this function supports.
    """
  'UNIX_DATE()':
    'prefix': 'unix_date'
    'body': 'unix_date(${1:date_expression})'
    'description': """
      Returns the number of days since 1970-01-01.
    """

  'CURRENT_DATETIME()':
    'prefix': 'current_datetime'
    'body': 'current_datetime(${1:[timezone]})'
    'description': """
      Returns the current time as a DATETIME object.

      This function supports an optional `timezone` parameter. See Timezone definitions for information on how to specify a time zone.
    """
  'DATETIME(year, month, day, hour, minute, second)':
    'prefix': 'datetime use INT'
    'body': 'datetime(${1:year}, ${2:month}, ${3:day}, ${4:hour}, ${5:minute}, ${6:second})'
    'description': """
      Constructs a `DATETIME` object using `INT64` values representing the year, month, day, hour, minute, and second.
    """
  'DATETIME(date, time)':
    'prefix': 'datetime use DATE TIME'
    'body': 'datetime(${1:date_expression}, ${2:time_expression})'
    'description': """
      Constructs a `DATETIME` object using a `DATE` object and a `TIME` object.
    """
  'DATETIME(timestamp)':
    'prefix': 'datetime use TIMESTAMP'
    'body': 'datetime(${1:timestamp_expression[, timezone]})'
    'description': """
      Constructs a `DATETIME` object using a `TIMESTAMP` object. It supports an optional parameter to specify a timezone. If no timezone is specified, the default timezone, UTC, is used.
    """
  'DATETIME_ADD()':
    'prefix': 'datetime_add'
    'body': 'datetime_add(${1:datetime_expression}, interval ${2:INT64_expr part})'
    'description': """
      Adds `INT64_expr` units of `part` to the DATETIME object.

      DATETIME_ADD supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
        * `DAY`
        * `WEEK`. Equivalent to 7 DAYs.
        * `MONTH`
        * `QUARTER`
        * `YEAR`

      Special handling is required for MONTH, QUARTER, and YEAR parts when the date is at (or near) the last day of the month. If the resulting month has fewer days than the original DATETIME's day, then the result day is the last day of the new month.
    """
  'DATETIME_SUB()':
    'prefix': 'datetime_sub'
    'body': 'datetime_sub(${1:datetime_expression}, INTERVAL ${2:INT64_expr part})'
    'description': """
      Subtracts `INT64_expr` units of `part` from the DATETIME.

      DATETIME_SUB supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
        * `DAY`
        * `WEEK`. Equivalent to 7 DAYs.
        * `MONTH`
        * `QUARTER`
        * `YEAR`

      Special handling is required for MONTH, QUARTER, and YEAR parts when the date is at (or near) the last day of the month. If the resulting month has fewer days than the original DATETIME's day, then the result day is the last day of the new month.
    """
  'DATETIME_DIFF()':
    'prefix': 'datetime_diff'
    'body': 'datetime_diff(${1:datetime_expression}, ${2:datetime_expression}, ${3:part})'
    'description': """
      Returns the number of `part` boundaries between the two `datetime_expressions`. If the first `DATETIME` occurs before the second `DATETIME`, then the result is non-positive. Throws an error if the computation overflows the result type, such as if the difference in microseconds between the two `DATETIME` objects would overflow an `INT64` value.

      DATETIME_DIFF supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
        * `DAY`
        * `WEEK` This date part begins on Sunday.
        * `ISOWEEK`: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
        * `MONTH`
        * `QUARTER`
        * `YEAR`
        * `ISOYEAR`: Uses the ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.
    """
  'DATETIME_TRUNC()':
    'prefix': 'datetime_trunc'
    'body': 'datetime_trunc(${1:datetime_expression}, ${2:part})'
    'description': """
      Truncates a `DATETIME` object to the granularity of `part`.

      DATETIME_TRUNC supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
        * `DAY`
        * `WEEK`
        * `WEEK(<WEEKDAY>)`: Truncates `datetime_expression` to the preceding week boundary, where weeks begin on `WEEKDAY`. Valid values for `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and `SATURDAY`.
        * `ISOWEEK`: Truncates `datetime_expression` to the preceding ISO 8601 week boundary. `ISOWEEK`s begin on Monday. The first `ISOWEEK` of each ISO year contains the first Thursday of the corresponding Gregorian calendar year. Any `date_expression` earlier than this will truncate to the preceding Monday.
        * `MONTH`
        * `QUARTER`
        * `YEAR`
        * `ISOYEAR`: Truncates `datetime_expression` to the preceding ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.
    """
  'FORMAT_DATETIME()':
    'prefix': 'format_datetime'
    'body': 'format_datetime(${1:format_string}, ${2:datetime_expression})'
    'description': """
      Formats a DATETIME object according to the specified `format_string`.

      See Supported Format Elements For DATETIME for a list of format elements that this function supports.
    """
  'PARSE_DATETIME()':
    'prefix': 'parse_datetime'
    'body': 'parse_datetime(${1:format_string}, ${2:string})'
    'description': """
      Uses a `format_string` and a `string` representation of a timestamp to return a TIMESTAMP object.

      See Supported Format Elements For DATETIME for a list of format elements that this function supports.

      When using PARSE_DATETIME, keep the following in mind:

        * **Unspecified fields**. Any unspecified field is initialized from `1970-01-01 00:00:00.0`. For instance, if the year is unspecified then it defaults to `1970`, and so on.
        * **Case insensitive names**. Names, such as `Monday`, `February`, and so on, are case insensitive.
        * **Whitespace**. One or more consecutive white spaces in the format string matches zero or more consecutive white spaces in the DATETIME string. In addition, leading and trailing white spaces in the DATETIME string are always allowed—even if they are not in the format string.
        * **Format precedence**. When two (or more) format elements have overlapping information (for example both `%F` and `%Y` affect the year), the last one generally overrides any earlier ones, with some exceptions (see the descriptions of `%s`, `%C`, and `%y`).
    """

  'CURRENT_TIME()':
    'prefix': 'current_time'
    'body': 'current_time()'
    'description': """
      Returns the current time as a TIME object.
    """
  'TIME(hour, minute, second)':
    'prefix': 'time use int'
    'body': 'time(${1:hour}, ${2:minute}, ${3:second})'
    'description': """
      Constructs a `TIME` object using `INT64` values representing the hour, minute, and second.
    """
  'TIME(datetime)':
    'prefix': 'time use object'
    'body': 'time(${1:datetime})'
    'description': """
      Constructs a `TIME` object using a `DATETIME` object.
    """
  'TIME(timestamp)':
    'prefix': 'time'
    'body': 'time(${1:timestamp[, timezone]})'
    'description': """
      Constructs a `TIME` object using a `TIMESTAMP` object. It supports an optional parameter to specify a timezone. If no timezone is specified, the default timezone, UTC, is used.
    """
  'TIME_ADD()':
    'prefix': 'time_add'
    'body': 'time_add(${1:time_expression}, interval ${2:INT64_expr part})'
    'description': """
      Adds `INT64_expr` units of `part` to the TIME object.

      TIME_ADD supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`

      This function automatically adjusts when values fall outside of the 00:00:00 to 24:00:00 boundary.
      For example, if you add an hour to `23:30:00`, the returned value is `00:30:00`.
    """
  'TIME_SUB()':
    'prefix': 'time_sub'
    'body': 'time_sub(${1:time_expression}, interval ${2:INT64_expr part})'
    'description': """
      Subtracts `INT64_expr` units of `part` from the TIME object.

      TIME_SUB supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`

      This function automatically adjusts when values fall outside of the 00:00:00 to 24:00:00 boundary.
      For example, if you subtract an hour from `00:30:00`, the returned value is `23:30:00`.
    """
  'TIME_DIFF()':
    'prefix': 'time_diff'
    'body': 'time_diff(${1:time_expression}, ${2:time_expression}, ${3:part})'
    'description': """
      Returns the number of whole specified `part` intervals between two TIME objects.
      Throws an error if the computation overflows the result type, such as if the difference in microseconds between the two time objects would overflow an INT64 value.

      TIME_DIFF supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
    """
  'TIME_TRUNC()':
    'prefix': 'time_trunc'
    'body': 'time_trunc(${1:time_expression}, ${2:part})'
    'description': """
      Truncates a TIME object to the granularity of `part`.

      TIME_TRUNC supports the following values for `part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
    """
  'FORMAT_TIME()':
    'prefix': 'format_time'
    'body': 'format_time(${1:format_string}, ${2:time_object})'
    'description': """
      Formats a TIME object according to the specified `format_string`.
      See Supported Format Elements For TIME for a list of format elements that this function supports.
    """
  'PARSE_TIME()':
    'prefix': 'parse_time'
    'body': 'parse_time(${1:format_string}, ${2:string})'
    'description': """
      Uses a `format_string` and a string to return a TIME object.
      See Supported Format Elements For TIME for a list of format elements that this function supports.

        * **Unspecified fields**. Any unspecified field is initialized from `00:00:00.0`. For instance, if seconds is unspecified then it defaults to `00`, and so on.
        * **Whitespace**. One or more consecutive white spaces in the format string matches zero or more consecutive white spaces in the TIME string. In addition, leading and trailing white spaces in the TIME string are always allowed—even if they are not in the format string.
        * **Format precedence**. When two (or more) format elements have overlapping information, the last one generally overrides any earlier ones.
    """

  'CURRENT_TIMESTAMP()':
    'prefix': 'current_timestamp'
    'body': 'current_timestamp()'
    'description': """
      Parentheses are optional. This function handles leap seconds by smearing them across a window of 20 hours around the inserted leap second. `CURRENT_TIMESTAMP()` produces a TIMESTAMP value that is continuous, non-ambiguous, has exactly 60 seconds per minute and does not repeat values over the leap second.
    """
  'EXTRACT(part FROM timestamp)':
    'prefix': 'extract timestamp'
    'body': 'extract(${1:part} from ${2:timestamp_expression [at time zone tz_spec]})'
    'description': """
      Returns an `INT64` value that corresponds to the specified `part` from a supplied `timestamp_expression`.

      Allowed `part` values are:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
        * `DAYOFWEEK`
        * `DAY`
        * `DAYOFYEAR`
        * `WEEK`: Returns the week number of the date in the range [0, 53]. Weeks begin with Sunday, and dates prior to the first Sunday of the year are in week 0.
        * `WEEK(<WEEKDAY>)`: Returns the week number of `timestamp_expression` in the range [0, 53]. Weeks begin on `WEEKDAY`. datetimes prior to the first `WEEKDAY` of the year are in week 0. Valid values for `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and `SATURDAY`.

        * `ISOWEEK`: Returns the ISO 8601 week number of the `datetime_expression`. `ISOWEEK`s begin on Monday. Return values are in the range [1, 53]. The first `ISOWEEK` of each ISO year begins on the Monday before the first Thursday of the Gregorian calendar year.

        * `MONTH`
        * `QUARTER`
        * `YEAR`
        * `ISOYEAR`: Returns the ISO 8601 week-numbering year, which is the Gregorian calendar year containing the Thursday of the week to which date_expression belongs.
        * `DATE`
        * `DATETIME`
        * `TIME`

      Returned values truncate lower order time periods. For example, when extracting seconds, `EXTRACT` truncates the millisecond and microsecond values.

      See Timezone definitions for information on how to specify a time zone.
    """
  'STRING()':
    'prefix': 'string'
    'body': 'string(${1:timestamp_expression[, timezone]})'
    'description': """
      Converts a `timestamp_expression` to a STRING data type. Supports an optional parameter to specify a timezone.
      See Timezone definitions for information on how to specify a time zone.
    """
  'TIMESTAMP(string)':
    'prefix': 'timestamp use STRING'
    'body': 'timestamp(${1:string_expression[, timezone]})'
    'description': """
      Converts a STRING expression to a TIMESTAMP data type.
    """
  'TIMESTAMP(date)':
    'prefix': 'timestamp use DATE'
    'body': 'timestamp(${1:date_expression[, timezone]})'
    'description': """
      Converts a DATE object to a TIMESTAMP data type.
    """
  'TIMESTAMP(datetime)':
    'prefix': 'timestamp use DATETIME'
    'body': 'timestamp(${1:datetime_expression[, timezone]})'
    'description': """
      Converts a DATETIME object to a TIMESTAMP data type.
    """
  'TIMESTAMP_ADD()':
    'prefix': 'timestamp_add'
    'body': 'timestamp_add(${1:timestamp_expression}, interval ${2:INT64_expr date_part})'
    'description': """
      Adds `INT64_expr` units of `date_part` to the timestamp, independent of any time zone.

      TIMESTAMP_ADD supports the following values for `date_part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`. Equivalent to 60 `MINUTE`s.
        * `DAY`. Equivalent to 24 `HOUR`s.
    """
  'TIMESTAMP_SUB()':
    'prefix': 'timestamp_sub'
    'body': 'timestamp_sub(${1:timestamp_expression}, interval ${2:INT64_expr date_part})'
    'description': """
      Subtracts `INT64_expr` units of `date_part` from the timestamp, independent of any time zone.

      TIMESTAMP_SUB supports the following values for `date_part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`. Equivalent to 60 `MINUTE`s.
        * `DAY`. Equivalent to 24 `HOUR`s.
    """
  'TIMESTAMP_DIFF()':
    'prefix': 'timestamp_diff'
    'body': 'timestamp_diff(${1:timestamp_expression}, ${2:timestamp_expression}, ${3:date_part})'
    'description': """
      Returns the number of whole specified `date_part` intervals between two timestamps. Throws an error if the computation overflows the result type, such as if the difference in microseconds between the two timestamps would overflow an INT64 value.

      TIMESTAMP_DIFF supports the following values for `date_part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`. Equivalent to 60 `MINUTE`s.
        * `DAY`. Equivalent to 24 `HOUR`s.
    """
  'TIMESTAMP_TRUNC()':
    'prefix': 'timestamp_trunc'
    'body': 'timestamp_trunc(${1:timestamp_expression}, ${2:date_part, [, time_zone]})'
    'description': """
      Truncates a timestamp to the granularity of `date_part`.

      TIMESTAMP_TRUNC supports the following values for `date_part`:

        * `MICROSECOND`
        * `MILLISECOND`
        * `SECOND`
        * `MINUTE`
        * `HOUR`
        * `DAY`
        * `WEEK`
        * `WEEK(<WEEKDAY>)`: Truncates `timestamp_expression` to the preceding week boundary, where weeks begin on `WEEKDAY`. Valid values for `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and `SATURDAY`.
        * `ISOWEEK`: Truncates `timestamp_expression` to the preceding ISO 8601 week boundary. `ISOWEEK`s begin on Monday. The first `ISOWEEK` of each ISO year contains the first Thursday of the corresponding Gregorian calendar year. Any date_expression earlier than this will truncate to the preceding Monday.
        * `MONTH`
        * `QUARTER`
        * `YEAR`
        * `ISOYEAR`: Truncates `timestamp_expression` to the preceding ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.

      Use this parameter if you want to use a time zone other than the default timezone, UTC, as part of the truncate operation.
    """
  'FORMAT_TIMESTAMP()':
    'prefix': 'format_timestamp'
    'body': 'format_timestamp(${1:format_string}, ${2:timestamp[, time_zone]})'
    'description': """
      Formats a timestamp according to the specified `format_string`.

      See Supported Format Elements For TIMESTAMP for a list of format elements that this function supports.
    """
  'PARSE_TIMESTAMP()':
    'prefix': 'parse_timestamp'
    'body': 'parse_timestamp(${1:format_string}, ${2:string[, time_zone]})'
    'description': """
      Uses a `format_string` and a string representation of a timestamp to return a TIMESTAMP object.

      When using PARSE_TIMESTAMP, keep the following in mind:

        * **Unspecified fields**. Any unspecified field is initialized from `1970-01-01 00:00:00.0`. This initialization value uses the time zone specified by the function's time zone argument, if present. If not, the initialization value uses the default time zone, UTC. For instance, if the year is unspecified then it defaults to `1970`, and so on.
        * **Case insensitive names**. Names, such as `Monday`, `February`, and so on, are case insensitive.
        * **Whitespace**. One or more consecutive white spaces in the format string matches zero or more consecutive white spaces in the timestamp string. In addition, leading and trailing white spaces in the timestamp string are always allowed -- even if they are not in the format string.
        * **Format precedence**. When two (or more) format elements have overlapping information (for example both `%F` and `%Y` affect the year), the last one generally overrides any earlier ones, with some exceptions (see the descriptions of `%s`, `%C`, and `%y`).

      See Supported Format Elements For TIMESTAMP for a list of format elements that this function supports.
    """
  'TIMESTAMP_SECONDS()':
    'prefix': 'timestamp_seconds'
    'body': 'timestamp_seconds(${1:int64_expression})'
    'description': """
      Interprets `int64_expression` as the number of seconds since 1970-01-01 00:00:00 UTC.
    """
  'TIMESTAMP_MILLIS()':
    'prefix': 'timestamp_millis'
    'body': 'timestamp_millis(${1:int64_expression})'
    'description': """
      Interprets `int64_expression` as the number of milliseconds since 1970-01-01 00:00:00 UTC.
    """
  'TIMESTAMP_MICROS()':
    'prefix': 'timestamp_micros'
    'body': 'timestamp_micros(${1:int64_expression})'
    'description': """
      Interprets `int64_expression` as the number of microseconds since 1970-01-01 00:00:00 UTC.
    """
  'UNIX_SECONDS()':
    'prefix': 'unix_seconds'
    'body': 'unix_seconds(${1:timestamp_expression})'
    'description': """
      Returns the number of seconds since 1970-01-01 00:00:00 UTC. Truncates higher levels of precision.
    """
  'UNIX_MILLIS()':
    'prefix': 'unix_millis'
    'body': 'unix_millis(${1:timestamp_expression})'
    'description': """
      Returns the number of milliseconds since 1970-01-01 00:00:00 UTC. Truncates higher levels of precision.
    """
  'UNIX_MICROS()':
    'prefix': 'unix_micros'
    'body': 'unix_micros(${1:timestamp_expression})'
    'description': """
      Returns the number of microseconds since 1970-01-01 00:00:00 UTC. Truncates higher levels of precision.
    """

  'SESSION_USER()':
    'prefix': 'session_user'
    'body': 'session_user()'
    'description': """
      Returns the email address of whoever is executing the query.
    """

  'NET.IP_FROM_STRING()':
    'prefix': 'net.ip_from_string'
    'body': 'net.ip_from_string(${1:addr_str})'
    'description': """
      Converts an IPv4 or IPv6 address from text (STRING) format to binary (BYTES) format in network byte order.

      This function supports the following formats for `addr_str`:

        * IPv4: Dotted-quad format. For example, `10.1.2.3`.
        * IPv6: Colon-separated format. For example, `1234:5678:90ab:cdef:1234:5678:90ab:cdef`. For more examples, see the IP Version 6 Addressing Architecture.

      This function does not support CIDR notation, such as `10.1.2.3/32`.

      If this function receives a `NULL` input, it returns `NULL`. If the input is considered invalid, an `OUT_OF_RANGE` error occurs.
    """
  'NET.SAFE_IP_FROM_STRING()':
    'prefix': 'net.safe_ip_from_string'
    'body': 'net.safe_ip_from_string(${1:addr_str})'
    'description': """
      Similar to NET.IP_FROM_STRING, but returns `NULL` instead of throwing an error if the input is invalid.
    """
  'NET.IP_TO_STRING()':
    'prefix': 'net.ip_to_string'
    'body': 'net.ip_to_string(${1:addr_bin})'
    'description': """
      Converts an IPv4 or IPv6 address from binary (BYTES) format in network byte order to text (STRING) format.

      If the input is 4 bytes, this function returns an IPv4 address as a STRING. If the input is 16 bytes, it returns an IPv6 address as a STRING.

      If this function receives a `NULL` input, it returns `NULL`. If the input has a length different from 4 or 16, an `OUT_OF_RANGE` error occurs.
    """
  'NET.IP_NET_MASK()':
    'prefix': 'net.ip_net_mask'
    'body': 'net.ip_net_mask(${1:num_output_bytes}, ${2:prefix_length})'
    'description': """
      Returns a network mask: a byte sequence with length equal to `num_output_bytes`, where the first `prefix_length` bits are set to 1 and the other bits are set to 0. `num_output_bytes` and `prefix_length` are INT64. This function throws an error if `num_output_bytes` is not 4 (for IPv4) or 16 (for IPv6). It also throws an error if `prefix_length` is negative or greater than `8 * num_output_bytes`.
    """
  'NET.IP_TRUNC()':
    'prefix': 'net.ip_trunc'
    'body': 'net.ip_trunc(${1:addr_bin}, ${2:prefix_length})'
    'description': """
      Takes `addr_bin`, an IPv4 or IPv6 address in binary (BYTES) format in network byte order, and returns a subnet address in the same format. The result has the same length as `addr_bin`, where the first `prefix_length` bits are equal to those in `addr_bin` and the remaining bits are 0.

      This function throws an error if `LENGTH(addr_bin)` is not 4 or 16, or if `prefix_length` is negative or greater than `LENGTH(addr_bin) * 8`.
    """
  'NET.IPV4_FROM_INT64()':
    'prefix': 'net.ipv4_from_int64'
    'body': 'net.ipv4_from_int64(${1:integer_value})'
    'description': """
      Converts an IPv4 address from integer format to binary (BYTES) format in network byte order. In the integer input, the least significant bit of the IP address is stored in the least significant bit of the integer, regardless of host or client architecture. For example, `1` means `0.0.0.1`, and `0x1FF` means `0.0.1.255`.

      This function checks that either all the most significant 32 bits are 0, or all the most significant 33 bits are 1 (sign-extended from a 32 bit integer). In other words, the input should be in the range `[-0x80000000, 0xFFFFFFFF]`; otherwise, this function throws an error.

      This function does not support IPv6.
    """
  'NET.IPV4_TO_INT64()':
    'prefix': 'net.ipv4_to_int64'
    'body': 'net.ipv4_to_int64(${1:addr_bin})'
    'description': """
      Converts an IPv4 address from binary (BYTES) format in network byte order to integer format. In the integer output, the least significant bit of the IP address is stored in the least significant bit of the integer, regardless of host or client architecture. For example, `1` means `0.0.0.1`, and `0x1FF` means `0.0.1.255`. The output is in the range `[0, 0xFFFFFFFF]`.

      If the input length is not 4, this function throws an error.

      This function does not support IPv6.
    """
  'NET.HOST()':
    'prefix': 'net.host'
    'body': 'net.host(${1:url})'
    'description': """
      Takes a URL as a STRING and returns the host as a STRING. For best results, URL values should comply with the format as defined by RFC 3986. If the URL value does not comply with RFC 3986 formatting, this function makes a best effort to parse the input and return a relevant result. If the function cannot parse the input, it returns NULL.
    """
  'NET.PUBLIC_SUFFIX()':
    'prefix': 'net.public_suffix'
    'body': 'net.public_suffix(${1:url})'
    'description': """
      Takes a URL as a STRING and returns the public suffix (such as `com`, `org`, or `net`) as a STRING. A public suffix is an ICANN domain registered at publicsuffix.org. For best results, URL values should comply with the format as defined by RFC 3986. If the URL value does not comply with RFC 3986 formatting, this function makes a best effort to parse the input and return a relevant result.

      This function returns NULL if any of the following is true:

        * It cannot parse the host from the input;
        * The parsed host contains adjacent dots in the middle (not leading or trailing);
        * The parsed host does not contain any public suffix.

      Before looking up the public suffix, this function temporarily normalizes the host by converting upper case English letters to lower case and encoding all non-ASCII characters with Punycode. The function then returns the public suffix as part of the original host instead of the normalized host.
    """
  'NET.REG_DOMAIN()':
    'prefix': 'net.reg_domain'
    'body': 'net.reg_domain(${1:url})'
    'description': """
      Takes a URL as a STRING and returns the registered or registerable domain (the public suffix plus one preceding label), as a STRING. For best results, URL values should comply with the format as defined by RFC 3986. If the URL value does not comply with RFC 3986 formatting, this function makes a best effort to parse the input and return a relevant result.

      This function returns NULL if any of the following is true:

        * It cannot parse the host from the input;
        * The parsed host contains adjacent dots in the middle (not leading or trailing);
        * The parsed host does not contain any public suffix;
        * The parsed host contains only a public suffix without any preceding label.

      Before looking up the public suffix, this function temporarily normalizes the host by converting upper case English letters to lowercase and encoding all non-ASCII characters with Punycode. The function then returns the registered or registerable domain as part of the original host instead of the normalized host.
    """

  'CASE expr WHEN value ... END':
    'prefix': 'case'
    'body': """
    case ${1:expr}
      when ${2:value} then ${3:result}
      when ${4:value} then ${5:result}
      else ${6:else_result}
    end
    """
    'description': """
      Compares `expr` to value of each successive `WHEN` clause and returns the first result where this comparison returns true. The remaining `WHEN` clauses and `else_result` are not evaluated. If the `expr = value` comparison returns false or `NULL` for all `WHEN` clauses, returns `else_result`. `expr` and value expressions must be implicitly coercible to a common supertype; equality comparisons are done on coerced values. `result` and `else_result` expressions must be coercible to a common supertype.
    """
  'CASE WHEN condition ... END':
    'prefix': 'casecond'
    'body': """
    case
      when ${1:cond} then ${2:result}
      when ${4:cond} then ${5:result}
      else ${6:else_result}
    end
    """
    'description': """
      Evaluates condition `cond` of each successive `WHEN` clause and returns the first result where the condition is true; any remaining `WHEN` clauses and `else_result` are not evaluated. If all conditions are false or `NULL`, returns `else_result`. `result` and `else_result` expressions must be implicitly coercible to a common supertype.
    """

  'COALESCE()':
    'prefix': 'coalesce'
    'body': 'coalesce(${1:expr1, ..., exprN})'
    'description': """
      Returns the value of the first non-null expression. The remaining expressions are not evaluated. All input expressions must be implicitly coercible to a common supertype.
    """
  'IF()':
    'prefix': 'if'
    'body': 'if(${1:cond}, ${2:true_result}, ${3:else_result})'
    'description': """
      If `cond` is true, returns `true_result`, else returns `else_result`. `else_result` is not evaluated if `cond` is true. `true_result` is not evaluated if `cond` is false or `NULL`. `true_result` and `else_result` must be coercible to a common supertype.
    """
  'IFNULL()':
    'prefix': 'ifnull'
    'body': 'ifnull(${1:expr}, ${2:null_result})'
    'description': """
      If `expr` is `NULL`, return `null_result`. Otherwise, return `expr`. If `expr` is not `NULL`, `null_result` is not evaluated. `expr` and `null_result` must be implicitly coercible to a common supertype. Synonym for `COALESCE(expr, null_result)`.
    """
  'NULLIF()':
    'prefix': 'nullif'
    'body': 'nullif(${1:expression}, ${2:expression_to_match})'
    'description': """
      Returns `NULL` if `expression = expression_to_match` is true, otherwise returns `expression`. `expression` and `expression_to_match` must be implicitly coercible to a common supertype; equality comparison is done on coerced values.
    """

  'EXTRACT(DAYOFWEEK FROM date_expression)':
    'prefix': 'dayofweek'
    'body': 'extract(dayofweek from ${1:date_expression})'
  'EXTRACT(DAY FROM date_expression)':
    'prefix': 'day'
    'body': 'extract(day from ${1:date_expression})'
  'EXTRACT(DAYOFYEAR FROM date_expression)':
    'prefix': 'dayofyear'
    'body': 'extract(dayofyear from ${1:date_expression})'
  'EXTRACT(WEEK FROM date_expression)':
    'prefix': 'week'
    'body': 'extract(week from ${1:date_expression})'
  'EXTRACT(WEEK<WEEKDAY> FROM date_expression)':
    'prefix': 'weekday'
    'body': 'extract(week(${1:<weekday>}) from ${2:date_expression})'
  'EXTRACT(ISOWEEK FROM date_expression)':
    'prefix': 'isoweek'
    'body': 'extract(isoweek from ${1:date_expression})'
  'EXTRACT(MONTH FROM date_expression)':
    'prefix': 'month'
    'body': 'extract(month from ${1:date_expression})'
  'EXTRACT(QUARTER FROM date_expression)':
    'prefix': 'quarter'
    'body': 'extract(quarter from ${1:date_expression})'
  'EXTRACT(YEAR FROM date_expression)':
    'prefix': 'year'
    'body': 'extract(year from ${1:date_expression})'
  'EXTRACT(ISOYEAR FROM date_expression)':
    'prefix': 'isoyear'
    'body': 'extract(isoyear from ${1:date_expression})'

  'EXTRACT(MICROSECOND FROM timestamp_expression)':
    'prefix': 'microsecond'
    'body': 'extract(microsecond from ${1:timestamp_expression [at time zone tz_spec]})'
  'EXTRACT(MILLISECOND FROM timestamp_expression)':
    'prefix': 'millisecond'
    'body': 'extract(millisecond from ${1:timestamp_expression [at time zone tz_spec]})'
  'EXTRACT(SECOND FROM timestamp_expression)':
    'prefix': 'second'
    'body': 'extract(second from ${1:timestamp_expression [at time zone tz_spec]})'
  'EXTRACT(MINUTE FROM timestamp_expression)':
    'prefix': 'minute'
    'body': 'extract(minute from ${1:timestamp_expression [at time zone tz_spec]})'
  'EXTRACT(HOUR FROM timestamp_expression)':
    'prefix': 'hour'
    'body': 'extract(hour from ${1:timestamp_expression [at time zone tz_spec]})'

  'ERROR()':
    'prefix': 'error'
    'body': 'error(${1:error_message})'
    'description': """
      Returns an error. The error_message argument is a STRING.

      BigQuery treats ERROR in the same way as any expression that may result in an error: there is no special guarantee of evaluation order.
    """

  'SAFE.prefix()':
    'prefix': 'safeprefix'
    'body': 'safeprefix.${1:function_name()}'
    'description': """
      If you begin a function with the SAFE. prefix, it will return NULL instead of an error. The SAFE. prefix only prevents errors from the prefixed function itself: it does not prevent errors that occur while evaluating argument expressions. The SAFE. prefix only prevents errors that occur because of the value of the function inputs, such as "value out of range" errors; other errors, such as internal or system errors, may still occur. If the function does not return an error, SAFE. has no effect on the output. If the function never returns an error, like RAND, then SAFE. has no effect.

      Operators, such as + and =, do not support the SAFE. prefix. To prevent errors from a division operation, use SAFE_DIVIDE. Some operators, such as IN, ARRAY, and UNNEST, resemble functions, but do not support the SAFE. prefix. The CAST and EXTRACT functions also do not support the SAFE. prefix. To prevent errors from casting, use SAFE_CAST.
    """

  'ML.EVALUATE()':
    'prefix': 'mlevaluate'
    'body': """
      ml.evaluate(model `${1:project}.${2:dataset}.${3:model}`,
      \t${4:\{table table_name | (query_statement)\}},
      \t${5:[struct(<T> as threshold)]})
    """
  'ML.ROC_CURVE()':
    'prefix': 'mlroccurve'
    'body': """
      ml.roc_curve(model `${1:project}.${2:dataset}.${3:model}`,
      \t${4:\{table table_name | (query_statement)\}},
      \t${5:[generate_array(thresholds)]})
    """
  'ML.CONFUSION_MATRIX()':
    'prefix': 'mlconfusionmatrix'
    'body': """
      ml.confusion_matrix(model `${1:project}.${2:dataset}.${3:model}`,
      \t${4:\{table table_name | (query_statement)\}},
      \t${5:[generate_array(thresholds)]})
    """
  'ML.TRAINING_INFO()':
    'prefix': 'mltraininginfo'
    'body': 'ml.training_info(model `${1:project}.${2:dataset}.${3:model}`)'
  'ML.FEATURE_INFO()':
    'prefix': 'mlfeatureinfo'
    'body': 'ml.feature_info(model `${1:project}.${2:dataset}.${3:model}`)'
  'ML.WEIGHTS()':
    'prefix': 'mlweights'
    'body': """
      ml.weights(model `${1:project}.${2:dataset}.${3:model}`,
      \t${4:[struct(<T> AS standardize)]})
    """
  'ML.PREDICT()':
    'prefix': 'mlpredict'
    'body': """
      ml.predict(model `${1:project}.${2:dataset}.${3:model}`,
      \t${4:\{table table_name | (query_statement)\}},
      \t${5:[struct(<threshold FLOAT64> AS threshold)]})
    """

  'ST_GEOGPOINT()':
    'prefix': 'stgeogpoint'
    'body': 'st_geopoint(${1:longitude}, ${2:latitude})'
  'ST_MAKELINE()':
    'prefix': 'stmakeline'
    'body': 'st_makeline(${1:geography_1, geography_2 | array_of_geography})'
  'ST_MAKEPOLYGON()':
    'prefix': 'stmakepolygon'
    'body': 'st_makepolygon(${1:geography_expression[, array_of_geography]})'
  'ST_MAKEPOLYGONORIENTED()':
    'prefix': 'stmakepolygonoriented'
    'body': 'st_makepolygonoriented(${1:array_of_geography})'
  'ST_GEOGFROMGEOJSON()':
    'prefix': 'stgeogfromgeojson'
    'body': 'st_geogfromgeojson(${1:geojson_string})'
  'ST_GEOGFROMTEXT()':
    'prefix': 'stgeogfromtext'
    'body': 'st_geogfromtext(${1:wkt_string})'
  'ST_ASGEOJSON()':
    'prefix': 'stasgeojson'
    'body': 'st_asgeojson(${1:geography_expression})'
  'ST_ASTEXT()':
    'prefix': 'stastext'
    'body': 'st_astext(${1:geography_expression})'
  'ST_BOUNDARY()':
    'prefix': 'stboundary'
    'body': 'st_boundary(${1:geography_expression})'
  'ST_CENTROID()':
    'prefix': 'stcentroid'
    'body': 'st_centroid(${1:geography_expression})'
  'ST_CLOSESTPOINT()':
    'prefix': 'stclosestpoint'
    'body': 'st_closestpoint(${1:geography_1}, ${2:geography_2[, spheroid=FALSE]})'
  'ST_DIFFERENCE()':
    'prefix': 'stdifference'
    'body': 'st_difference(${1:geography_1}, ${2:geography_2})'
  'ST_INTERSECTION()':
    'prefix': 'stintersection'
    'body': 'st_intersection(${1:geography_1}, ${2:geography_2})'
  'ST_SNAPTOGRID()':
    'prefix': 'stsnaptogrid'
    'body': 'st_snaptogrid(${1:geography_expression}, ${2:grid_size})'
  'ST_UNION()':
    'prefix': 'stunion'
    'body': 'st_union(${1:geography_1, geography_2 | array_of_geography})'
  'ST_CONTAINS()':
    'prefix': 'stcontains'
    'body': 'st_contains(${1:geography_1}, ${2:geography_2})'
  'ST_COVEREDBY()':
    'prefix': 'stcoveredby'
    'body': 'st_coveredby(${1:geography_1}, ${2:geography_2})'
  'ST_COVERS()':
    'prefix': 'stcovers'
    'body': 'st_covers(${1:geography_1}, ${2:geography_2})'
  'ST_DISJOINT()':
    'prefix': 'stdisjoint'
    'body': 'st_disjoint(${1:geography_1}, ${2:geography_2})'
  'ST_DWITHIN()':
    'prefix': 'stdwithin'
    'body': 'st_dwithin(${1:geography_1}, ${2:geography_2}, ${3:distance[, spheroid=FALSE]})'
  'ST_EQUALS()':
    'prefix': 'stequals'
    'body': 'st_equals(${1:geography_1}, ${2:geography_2})'
  'ST_INTERSECTS()':
    'prefix': 'stintersects'
    'body': 'st_intersects(${1:geography_1}, ${2:geography_2})'
  'ST_INTERSECTSBOX()':
    'prefix': 'stintersectsbox'
    'body': 'st_intersectsbox(${1:geography}, ${2:lng1}, ${3:lat1}, ${4:lng2}, ${5:lat2})'
  'ST_TOUCHES()':
    'prefix': 'sttouches'
    'body': 'st_touches(${1:geography_1}, ${2:geography_2})'
  'ST_WITHIN()':
    'prefix': 'stwithin'
    'body': 'st_within(${1:geography_1}, ${2:geography_2})'
  'ST_ISEMPTY()':
    'prefix': 'stisempty'
    'body': 'st_isempty(${1:geography_expression})'
  'ST_ISCOLLECTION()':
    'prefix': 'stiscollection'
    'body': 'st_iscollection(${1:geography_expression})'
  'ST_DIMENSION()':
    'prefix': 'stdimension'
    'body': 'st_dimension(${1:geography_expression})'
  'ST_NUMPOINTS()':
    'prefix': 'stnumpoints'
    'body': 'st_numpoints(${1:geography_expression})'
  'ST_AREA()':
    'prefix': 'starea'
    'body': 'st_area(${1:geography_expression[, spheroid=falsefalse]})'
  'ST_DISTANCE()':
    'prefix': 'stdistance'
    'body': 'st_distance(${1:geography_1}, ${2:geography_2[, spheroid=false]})'
  'ST_LENGTH()':
    'prefix': 'stlength'
    'body': 'st_length(${1:geography_expression[, spheroid=false]})'
  'ST_MAXDISTANCE()':
    'prefix': 'stmaxdistance'
    'body': 'st_maxdistance(${1:geography_1}, ${2:geography_2[, spheroid=false]})'
  'ST_PERIMETER()':
    'prefix': 'stperimeter'
    'body': 'st_perimeter(${1:geography_expression[, spheroid=false]})'
  'ST_UNION_AGG()':
    'prefix': 'stunionagg'
    'body': 'st_union_agg(${1:geography})'

  'KEYS.NEW_KEYSET':
    'prefix': 'keysnew_keyset'
    'body': 'keys.new_keyset(${1:key_type})'
  'KEYS.ADD_KEY_FROM_RAW_BYTES':
    'prefix': 'keysadd_key_from_raw_bytes'
    'body': 'keys.add_key_from_raw_bytes(${1:keyset}, ${2:key_type}, ${3:raw_key_bytes})'
  'AEAD.DECRYPT_BYTES':
    'prefix': 'aeaddecrypt_bytes'
    'body': 'aead.decrypt_bytes(${1:keyset}, ${2:ciphertext}, ${3:additional_data})'
  'AEAD.DECRYPT_STRING':
    'prefix': 'aeaddecrypt_string'
    'body': 'aead.decrypt_string(${1:keyset}, ${2:ciphertext}, ${3:additional_data})'
  'AEAD.ENCRYPT':
    'prefix': 'aeadencrypt'
    'body': 'aead.encrypt(${1:keyset}, ${2:plaintext}, ${3:additional_data})'
  'KEYS.KEYSET_FROM_JSON':
    'prefix': 'keyskeyset_from_json'
    'body': 'keys.keyset_from_json(${1:json_keyset})'
  'KEYS.KEYSET_TO_JSON':
    'prefix': 'keyskeyset_to_json'
    'body': 'keys.keyset_to_json(${1:keyset})'
  'KEYS.ROTATE_KEYSET':
    'prefix': 'keysrotate_keyset'
    'body': 'keys.rotate_keyset(${1:keyset}, ${2:key_type})'

  'INFORMATION_SCHEMA.SCHEMATA':
    'prefix': 'informationschemata'
    'body': 'information_schema.schemata'
    'description': """
      When you query the INFORMATION_SCHEMA.SCHEMATA view, the query results contain one row for each dataset in a project to which the current user has access.
    """

  'INFORMATION_SCHEMA.SCHEMATA_OPTIONS':
    'prefix': 'informationschemataoptions'
    'body': 'information_schema.schemata_options'
    'description': """
      When you query the INFORMATION_SCHEMA.SCHEMATA_OPTIONS view, the query results contain one row for each dataset in a project to which the current user has access.
    """

  'INFORMATION_SCHEMA.TABLES':
    'prefix': 'informationtables'
    'body': 'information_schema.tables'
    'description': """
      When you query the INFORMATION_SCHEMA.TABLES view, the query results contain one row for each table or view in a dataset.
    """

  'INFORMATION_SCHEMA.TABLE_OPTIONS':
    'prefix': 'informationtableoptions'
    'body': 'information_schema.table_options'
    'description': """
      When you query the INFORMATION_SCHEMA.TABLE_OPTIONS view, the query results contain one row for each table or view in a dataset.
    """

  'INFORMATION_SCHEMA.COLUMNS':
    'prefix': 'informationcolumns'
    'body': 'information_schema.columns'
    'description': """
      When you query the INFORMATION_SCHEMA.COLUMNS view, the query results contain one row for each column (field) in a table.
    """

  'INFORMATION_SCHEMA.VIEWS':
    'prefix': 'informationviews'
    'body': 'information_schema.views'
    'description': """
      When you query the INFORMATION_SCHEMA.VIEWS view, the query results contain one row for each view in a dataset.
    """

  'SELECT ... FROM INFORMATION_SCHEMA.SCHEMATA':
    'prefix': 'selectinformationschemata'
    'body': """
      select
      \tcatalog_name,
      \tschema_name,
      \tschema_owner,
      \tcreation_time,
      \tlast_modified_time,
      \tlocation
      from
      \t`${1:project}.information_schema.SCHEMATA`
      order by
      \tschema_name
    """
    'description': """
      When you query the INFORMATION_SCHEMA.SCHEMATA view, the query results contain one row for each dataset in a project to which the current user has access.
    """

  'SELECT ... FROM INFORMATION_SCHEMA.SCHEMATA_OPTIONS':
    'prefix': 'selectinformationschemataoptions'
    'body': """
      select
      \tcatalog_name,
      \tschema_name,
      \toption_name,
      \toption_type,
      \toption_value
      from
      \t`${1:project}.information_schema.schemata_options`
      order by
      \tschema_name, option_name
    """
    'description': """
      When you query the INFORMATION_SCHEMA.SCHEMATA_OPTIONS view, the query results contain one row for each dataset in a project to which the current user has access.
    """

  'SELECT ... FROM INFORMATION_SCHEMA.TABLES':
    'prefix': 'selectinformationtables'
    'body': """
      select
      \ttable_catalog,
      \ttable_schema,
      \ttable_name,
      \ttable_type,
      \tis_insertable_into,
      \tis_typed,
      \tcreation_time
      from
      \t`${1:project}.${2:dataset}.information_schema.tables`
      order by
      \ttable_name
    """
    'description': """
      When you query the INFORMATION_SCHEMA.TABLES view, the query results contain one row for each table or view in a dataset.
    """

  'SELECT ... FROM INFORMATION_SCHEMA.TABLE_OPTIONS':
    'prefix': 'selectinformationtableoptions'
    'body': """
      select
      \ttable_catalog,
      \ttable_schema,
      \ttable_name,
      \toption_name,
      \toption_type,
      \toption_value
      from
      \t`${1:project}.${2:dataset}.information_schema.table_options`
      order by
      \ttable_name, option_name
    """
    'description': """
      When you query the INFORMATION_SCHEMA.TABLE_OPTIONS view, the query results contain one row for each table or view in a dataset.
    """

  'SELECT ... FROM INFORMATION_SCHEMA.COLUMNS':
    'prefix': 'selectinformationcolumns'
    'body': """
      select
      \ttable_catalog,
      \ttable_schema,
      \ttable_name,
      \tcolumn_name,
      \tordinal_position,
      \tis_nullable,
      \tdata_type,
      \tis_generated,
      \tgeneration_expression,
      \tis_stored,
      \tis_hidden,
      \tis_updatable,
      \tis_system_defined,
      \tis_partitioning_column,
      \tclustering_ordinal_position
      from
      \t`${1:project}.${2:dataset}.information_schema.columns`
      order by
      \ttable_name, ordinal_position
    """
    'description': """
      When you query the INFORMATION_SCHEMA.COLUMNS view, the query results contain one row for each column (field) in a table.
    """

  'SELECT ... FROM INFORMATION_SCHEMA.VIEWS':
    'prefix': 'selectinformationviews'
    'body': """
      select
      \ttable_catalog,
      \ttable_schema,
      \ttable_name,
      \tview_definition,
      \tcheck_option,
      \tuse_standard_sql
      from
      \t`${1:project}.${2:dataset}.information_schema.view`
      order by
      \ttable_name
    """
    'description': """
      When you query the INFORMATION_SCHEMA.VIEWS view, the query results contain one row for each view in a dataset.
    """
